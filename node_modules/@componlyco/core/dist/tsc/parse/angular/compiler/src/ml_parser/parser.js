"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = exports.ParseTreeResult = exports.TreeError = void 0;
var parse_util_1 = require("../parse_util");
var html = __importStar(require("./ast"));
var entities_1 = require("./entities");
var lexer_1 = require("./lexer");
var tags_1 = require("./tags");
var TreeError = (function (_super) {
    __extends(TreeError, _super);
    function TreeError(elementName, span, msg) {
        var _this = _super.call(this, span, msg) || this;
        _this.elementName = elementName;
        return _this;
    }
    TreeError.create = function (elementName, span, msg) {
        return new TreeError(elementName, span, msg);
    };
    return TreeError;
}(parse_util_1.ParseError));
exports.TreeError = TreeError;
var ParseTreeResult = (function () {
    function ParseTreeResult(rootNodes, errors) {
        this.rootNodes = rootNodes;
        this.errors = errors;
    }
    return ParseTreeResult;
}());
exports.ParseTreeResult = ParseTreeResult;
var Parser = (function () {
    function Parser(getTagDefinition) {
        this.getTagDefinition = getTagDefinition;
    }
    Parser.prototype.parse = function (source, url, options) {
        var tokenizeResult = (0, lexer_1.tokenize)(source, url, this.getTagDefinition, options);
        var parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
        parser.build();
        return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
    };
    return Parser;
}());
exports.Parser = Parser;
var _TreeBuilder = (function () {
    function _TreeBuilder(tokens, getTagDefinition) {
        this.tokens = tokens;
        this.getTagDefinition = getTagDefinition;
        this._index = -1;
        this._containerStack = [];
        this.rootNodes = [];
        this.errors = [];
        this._advance();
    }
    _TreeBuilder.prototype.build = function () {
        while (this._peek.type !== 24) {
            if (this._peek.type === 0 ||
                this._peek.type === 4) {
                this._consumeStartTag(this._advance());
            }
            else if (this._peek.type === 3) {
                this._consumeEndTag(this._advance());
            }
            else if (this._peek.type === 12) {
                this._closeVoidElement();
                this._consumeCdata(this._advance());
            }
            else if (this._peek.type === 10) {
                this._closeVoidElement();
                this._consumeComment(this._advance());
            }
            else if (this._peek.type === 5 || this._peek.type === 7 ||
                this._peek.type === 6) {
                this._closeVoidElement();
                this._consumeText(this._advance());
            }
            else if (this._peek.type === 19) {
                this._consumeExpansion(this._advance());
            }
            else if (this._peek.type === 25) {
                this._closeVoidElement();
                this._consumeBlockGroupOpen(this._advance());
            }
            else if (this._peek.type === 29) {
                this._closeVoidElement();
                this._consumeBlock(this._advance(), 30);
            }
            else if (this._peek.type === 27) {
                this._closeVoidElement();
                this._consumeBlockGroupClose(this._advance());
            }
            else {
                this._advance();
            }
        }
    };
    _TreeBuilder.prototype._advance = function () {
        var prev = this._peek;
        if (this._index < this.tokens.length - 1) {
            this._index++;
        }
        this._peek = this.tokens[this._index];
        return prev;
    };
    _TreeBuilder.prototype._advanceIf = function (type) {
        if (this._peek.type === type) {
            return this._advance();
        }
        return null;
    };
    _TreeBuilder.prototype._consumeCdata = function (_startToken) {
        this._consumeText(this._advance());
        this._advanceIf(13);
    };
    _TreeBuilder.prototype._consumeComment = function (token) {
        var text = this._advanceIf(7);
        var endToken = this._advanceIf(11);
        var value = text != null ? text.parts[0].trim() : null;
        var sourceSpan = endToken == null ?
            token.sourceSpan :
            new parse_util_1.ParseSourceSpan(token.sourceSpan.start, endToken.sourceSpan.end, token.sourceSpan.fullStart);
        this._addToParent(new html.Comment(value, sourceSpan));
    };
    _TreeBuilder.prototype._consumeExpansion = function (token) {
        var switchValue = this._advance();
        var type = this._advance();
        var cases = [];
        while (this._peek.type === 20) {
            var expCase = this._parseExpansionCase();
            if (!expCase)
                return;
            cases.push(expCase);
        }
        if (this._peek.type !== 23) {
            this.errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
            return;
        }
        var sourceSpan = new parse_util_1.ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);
        this._addToParent(new html.Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
        this._advance();
    };
    _TreeBuilder.prototype._parseExpansionCase = function () {
        var value = this._advance();
        if (this._peek.type !== 21) {
            this.errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
            return null;
        }
        var start = this._advance();
        var exp = this._collectExpansionExpTokens(start);
        if (!exp)
            return null;
        var end = this._advance();
        exp.push({ type: 24, parts: [], sourceSpan: end.sourceSpan });
        var expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
        expansionCaseParser.build();
        if (expansionCaseParser.errors.length > 0) {
            this.errors = this.errors.concat(expansionCaseParser.errors);
            return null;
        }
        var sourceSpan = new parse_util_1.ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);
        var expSourceSpan = new parse_util_1.ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);
        return new html.ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    };
    _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {
        var exp = [];
        var expansionFormStack = [21];
        while (true) {
            if (this._peek.type === 19 ||
                this._peek.type === 21) {
                expansionFormStack.push(this._peek.type);
            }
            if (this._peek.type === 22) {
                if (lastOnStack(expansionFormStack, 21)) {
                    expansionFormStack.pop();
                    if (expansionFormStack.length === 0)
                        return exp;
                }
                else {
                    this.errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                    return null;
                }
            }
            if (this._peek.type === 23) {
                if (lastOnStack(expansionFormStack, 19)) {
                    expansionFormStack.pop();
                }
                else {
                    this.errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                    return null;
                }
            }
            if (this._peek.type === 24) {
                this.errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                return null;
            }
            exp.push(this._advance());
        }
    };
    _TreeBuilder.prototype._consumeText = function (token) {
        var tokens = [token];
        var startSpan = token.sourceSpan;
        var text = token.parts[0];
        if (text.length > 0 && text[0] === '\n') {
            var parent_1 = this._getContainer();
            if (parent_1 instanceof html.BlockGroup) {
                this.errors.push(TreeError.create(null, startSpan, 'Text cannot be placed directly inside of a block group.'));
                return null;
            }
            if (parent_1 != null && parent_1.children.length === 0 &&
                this.getTagDefinition(parent_1.name).ignoreFirstLf) {
                text = text.substring(1);
                tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };
            }
        }
        while (this._peek.type === 8 || this._peek.type === 5 ||
            this._peek.type === 9) {
            token = this._advance();
            tokens.push(token);
            if (token.type === 8) {
                text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);
            }
            else if (token.type === 9) {
                text += token.parts[0];
            }
            else {
                text += token.parts.join('');
            }
        }
        if (text.length > 0) {
            var endSpan = token.sourceSpan;
            this._addToParent(new html.Text(text, new parse_util_1.ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));
        }
    };
    _TreeBuilder.prototype._closeVoidElement = function () {
        var el = this._getContainer();
        if (el instanceof html.Element && this.getTagDefinition(el.name).isVoid) {
            this._containerStack.pop();
        }
    };
    _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {
        var _a = __read(startTagToken.parts, 2), prefix = _a[0], name = _a[1];
        var attrs = [];
        while (this._peek.type === 14) {
            attrs.push(this._consumeAttr(this._advance()));
        }
        var fullName = this._getElementFullName(prefix, name, this._getClosestParentElement());
        var selfClosing = false;
        if (this._peek.type === 2) {
            this._advance();
            selfClosing = true;
            var tagDef = this.getTagDefinition(fullName);
            if (!(tagDef.canSelfClose || (0, tags_1.getNsPrefix)(fullName) !== null || tagDef.isVoid)) {
                this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void, custom and foreign elements can be self closed \"".concat(startTagToken.parts[1], "\"")));
            }
        }
        else if (this._peek.type === 1) {
            this._advance();
            selfClosing = false;
        }
        var end = this._peek.sourceSpan.fullStart;
        var span = new parse_util_1.ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
        var startSpan = new parse_util_1.ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
        var el = new html.Element(fullName, attrs, [], span, startSpan, undefined);
        var parentEl = this._getContainer();
        this._pushContainer(el, parentEl instanceof html.Element &&
            this.getTagDefinition(parentEl.name).isClosedByChild(el.name));
        if (selfClosing) {
            this._popContainer(fullName, html.Element, span);
        }
        else if (startTagToken.type === 4) {
            this._popContainer(fullName, html.Element, null);
            this.errors.push(TreeError.create(fullName, span, "Opening tag \"".concat(fullName, "\" not terminated.")));
        }
    };
    _TreeBuilder.prototype._pushContainer = function (node, isClosedByChild) {
        if (isClosedByChild) {
            this._containerStack.pop();
        }
        this._addToParent(node);
        this._containerStack.push(node);
    };
    _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {
        var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getClosestParentElement());
        if (this.getTagDefinition(fullName).isVoid) {
            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"".concat(endTagToken.parts[1], "\"")));
        }
        else if (!this._popContainer(fullName, html.Element, endTagToken.sourceSpan)) {
            var errMsg = "Unexpected closing tag \"".concat(fullName, "\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags");
            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
        }
    };
    _TreeBuilder.prototype._popContainer = function (fullName, expectedType, endSourceSpan) {
        var _a;
        var unexpectedCloseTagDetected = false;
        for (var stackIndex = this._containerStack.length - 1; stackIndex >= 0; stackIndex--) {
            var node = this._containerStack[stackIndex];
            var name_1 = node instanceof html.BlockGroup ? (_a = node.blocks[0]) === null || _a === void 0 ? void 0 : _a.name : node.name;
            if (name_1 === fullName && node instanceof expectedType) {
                node.endSourceSpan = endSourceSpan;
                node.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : node.sourceSpan.end;
                this._containerStack.splice(stackIndex, this._containerStack.length - stackIndex);
                return !unexpectedCloseTagDetected;
            }
            if (node instanceof html.BlockGroup ||
                node instanceof html.Element && !this.getTagDefinition(node.name).closedByParent) {
                unexpectedCloseTagDetected = true;
            }
        }
        return false;
    };
    _TreeBuilder.prototype._consumeAttr = function (attrName) {
        var fullName = (0, tags_1.mergeNsAndName)(attrName.parts[0], attrName.parts[1]);
        var attrEnd = attrName.sourceSpan.end;
        if (this._peek.type === 15) {
            this._advance();
        }
        var value = '';
        var valueTokens = [];
        var valueStartSpan = undefined;
        var valueEnd = undefined;
        var nextTokenType = this._peek.type;
        if (nextTokenType === 16) {
            valueStartSpan = this._peek.sourceSpan;
            valueEnd = this._peek.sourceSpan.end;
            while (this._peek.type === 16 ||
                this._peek.type === 17 ||
                this._peek.type === 9) {
                var valueToken = this._advance();
                valueTokens.push(valueToken);
                if (valueToken.type === 17) {
                    value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);
                }
                else if (valueToken.type === 9) {
                    value += valueToken.parts[0];
                }
                else {
                    value += valueToken.parts.join('');
                }
                valueEnd = attrEnd = valueToken.sourceSpan.end;
            }
        }
        if (this._peek.type === 15) {
            var quoteToken = this._advance();
            attrEnd = quoteToken.sourceSpan.end;
        }
        var valueSpan = valueStartSpan && valueEnd &&
            new parse_util_1.ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);
        return new html.Attribute(fullName, value, new parse_util_1.ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);
    };
    _TreeBuilder.prototype._consumeBlockGroupOpen = function (token) {
        var end = this._peek.sourceSpan.fullStart;
        var span = new parse_util_1.ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);
        var startSpan = new parse_util_1.ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);
        var blockGroup = new html.BlockGroup([], span, startSpan, null);
        this._pushContainer(blockGroup, false);
        var implicitBlock = this._consumeBlock(token, 26);
        startSpan.end = implicitBlock.startSourceSpan.end;
    };
    _TreeBuilder.prototype._consumeBlock = function (token, closeToken) {
        this._conditionallyClosePreviousBlock();
        var parameters = [];
        while (this._peek.type === 28) {
            var paramToken = this._advance();
            parameters.push(new html.BlockParameter(paramToken.parts[0], paramToken.sourceSpan));
        }
        if (this._peek.type === closeToken) {
            this._advance();
        }
        var end = this._peek.sourceSpan.fullStart;
        var span = new parse_util_1.ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);
        var startSpan = new parse_util_1.ParseSourceSpan(token.sourceSpan.start, end, token.sourceSpan.fullStart);
        var block = new html.Block(token.parts[0], parameters, [], span, startSpan);
        var parent = this._getContainer();
        if (!(parent instanceof html.BlockGroup)) {
            this.errors.push(TreeError.create(block.name, block.sourceSpan, 'Blocks can only be placed inside of block groups.'));
        }
        else {
            parent.blocks.push(block);
            this._containerStack.push(block);
        }
        return block;
    };
    _TreeBuilder.prototype._consumeBlockGroupClose = function (token) {
        var name = token.parts[0];
        var previousContainer = this._getContainer();
        this._conditionallyClosePreviousBlock();
        if (!this._popContainer(name, html.BlockGroup, token.sourceSpan)) {
            var context = previousContainer instanceof html.Element ?
                "There is an unclosed \"".concat(previousContainer.name, "\" HTML tag named that may have to be closed first.") :
                "The block may have been closed earlier.";
            this.errors.push(TreeError.create(name, token.sourceSpan, "Unexpected closing block \"".concat(name, "\". ").concat(context)));
        }
    };
    _TreeBuilder.prototype._conditionallyClosePreviousBlock = function () {
        var container = this._getContainer();
        if (container instanceof html.Block) {
            var lastChild = container.children.length ? container.children[container.children.length - 1] : null;
            var endSpan = lastChild === null ?
                null :
                new parse_util_1.ParseSourceSpan(lastChild.sourceSpan.end, lastChild.sourceSpan.end);
            this._popContainer(container.name, html.Block, endSpan);
        }
    };
    _TreeBuilder.prototype._getContainer = function () {
        return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] :
            null;
    };
    _TreeBuilder.prototype._getClosestParentElement = function () {
        for (var i = this._containerStack.length - 1; i > -1; i--) {
            if (this._containerStack[i] instanceof html.Element) {
                return this._containerStack[i];
            }
        }
        return null;
    };
    _TreeBuilder.prototype._addToParent = function (node) {
        var parent = this._getContainer();
        if (parent === null) {
            this.rootNodes.push(node);
        }
        else if (parent instanceof html.BlockGroup) {
            this.errors.push(TreeError.create(null, node.sourceSpan, 'Block groups can only contain blocks.'));
        }
        else {
            parent.children.push(node);
        }
    };
    _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {
        if (prefix === '') {
            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';
            if (prefix === '' && parentElement != null) {
                var parentTagName = (0, tags_1.splitNsName)(parentElement.name)[1];
                var parentTagDefinition = this.getTagDefinition(parentTagName);
                if (!parentTagDefinition.preventNamespaceInheritance) {
                    prefix = (0, tags_1.getNsPrefix)(parentElement.name);
                }
            }
        }
        return (0, tags_1.mergeNsAndName)(prefix, localName);
    };
    return _TreeBuilder;
}());
function lastOnStack(stack, element) {
    return stack.length > 0 && stack[stack.length - 1] === element;
}
function decodeEntity(match, entity) {
    if (entities_1.NAMED_ENTITIES[entity] !== undefined) {
        return entities_1.NAMED_ENTITIES[entity] || match;
    }
    if (/^#x[a-f0-9]+$/i.test(entity)) {
        return String.fromCodePoint(parseInt(entity.slice(2), 16));
    }
    if (/^#\d+$/.test(entity)) {
        return String.fromCodePoint(parseInt(entity.slice(1), 10));
    }
    return match;
}
