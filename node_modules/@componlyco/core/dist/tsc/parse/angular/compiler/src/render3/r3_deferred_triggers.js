"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDeferredTime = exports.getTriggerParametersStart = exports.parseOnTrigger = exports.parseWhenTrigger = void 0;
var chars = __importStar(require("../chars"));
var lexer_1 = require("../expression_parser/lexer");
var parse_util_1 = require("../parse_util");
var t = __importStar(require("./r3_ast"));
var TIME_PATTERN = /^\d+(ms|s)?$/;
var SEPARATOR_PATTERN = /^\s$/;
var COMMA_DELIMITED_SYNTAX = new Map([
    [chars.$LBRACE, chars.$RBRACE],
    [chars.$LBRACKET, chars.$RBRACKET],
    [chars.$LPAREN, chars.$RPAREN],
]);
var OnTriggerType;
(function (OnTriggerType) {
    OnTriggerType["IDLE"] = "idle";
    OnTriggerType["TIMER"] = "timer";
    OnTriggerType["INTERACTION"] = "interaction";
    OnTriggerType["IMMEDIATE"] = "immediate";
    OnTriggerType["HOVER"] = "hover";
    OnTriggerType["VIEWPORT"] = "viewport";
})(OnTriggerType || (OnTriggerType = {}));
function parseWhenTrigger(_a, bindingParser, triggers, errors) {
    var expression = _a.expression, sourceSpan = _a.sourceSpan;
    var whenIndex = expression.indexOf('when');
    if (whenIndex === -1) {
        errors.push(new parse_util_1.ParseError(sourceSpan, "Could not find \"when\" keyword in expression"));
    }
    else {
        var start = getTriggerParametersStart(expression, whenIndex + 1);
        var parsed = bindingParser.parseBinding(expression.slice(start), false, sourceSpan, sourceSpan.start.offset + start);
        trackTrigger('when', triggers, errors, new t.BoundDeferredTrigger(parsed, sourceSpan));
    }
}
exports.parseWhenTrigger = parseWhenTrigger;
function parseOnTrigger(_a, triggers, errors) {
    var expression = _a.expression, sourceSpan = _a.sourceSpan;
    var onIndex = expression.indexOf('on');
    if (onIndex === -1) {
        errors.push(new parse_util_1.ParseError(sourceSpan, "Could not find \"on\" keyword in expression"));
    }
    else {
        var start = getTriggerParametersStart(expression, onIndex + 1);
        var parser = new OnTriggerParser(expression, start, sourceSpan, triggers, errors);
        parser.parse();
    }
}
exports.parseOnTrigger = parseOnTrigger;
var OnTriggerParser = (function () {
    function OnTriggerParser(expression, start, span, triggers, errors) {
        this.expression = expression;
        this.start = start;
        this.span = span;
        this.triggers = triggers;
        this.errors = errors;
        this.index = 0;
        this.tokens = new lexer_1.Lexer().tokenize(expression.slice(start));
    }
    OnTriggerParser.prototype.parse = function () {
        while (this.tokens.length > 0 && this.index < this.tokens.length) {
            var token = this.token();
            if (!token.isIdentifier()) {
                this.unexpectedToken(token);
                break;
            }
            if (this.isFollowedByOrLast(chars.$COMMA)) {
                this.consumeTrigger(token, []);
                this.advance();
            }
            else if (this.isFollowedByOrLast(chars.$LPAREN)) {
                this.advance();
                var prevErrors = this.errors.length;
                var parameters = this.consumeParameters();
                if (this.errors.length !== prevErrors) {
                    break;
                }
                this.consumeTrigger(token, parameters);
                this.advance();
            }
            else if (this.index < this.tokens.length - 1) {
                this.unexpectedToken(this.tokens[this.index + 1]);
            }
            this.advance();
        }
    };
    OnTriggerParser.prototype.advance = function () {
        this.index++;
    };
    OnTriggerParser.prototype.isFollowedByOrLast = function (char) {
        if (this.index === this.tokens.length - 1) {
            return true;
        }
        return this.tokens[this.index + 1].isCharacter(char);
    };
    OnTriggerParser.prototype.token = function () {
        return this.tokens[Math.min(this.index, this.tokens.length - 1)];
    };
    OnTriggerParser.prototype.consumeTrigger = function (identifier, parameters) {
        var startSpan = this.span.start.moveBy(this.start + identifier.index - this.tokens[0].index);
        var endSpan = startSpan.moveBy(this.token().end - identifier.index);
        var sourceSpan = new parse_util_1.ParseSourceSpan(startSpan, endSpan);
        try {
            switch (identifier.toString()) {
                case OnTriggerType.IDLE:
                    this.trackTrigger('idle', createIdleTrigger(parameters, sourceSpan));
                    break;
                case OnTriggerType.TIMER:
                    this.trackTrigger('timer', createTimerTrigger(parameters, sourceSpan));
                    break;
                case OnTriggerType.INTERACTION:
                    this.trackTrigger('interaction', createInteractionTrigger(parameters, sourceSpan));
                    break;
                case OnTriggerType.IMMEDIATE:
                    this.trackTrigger('immediate', createImmediateTrigger(parameters, sourceSpan));
                    break;
                case OnTriggerType.HOVER:
                    this.trackTrigger('hover', createHoverTrigger(parameters, sourceSpan));
                    break;
                case OnTriggerType.VIEWPORT:
                    this.trackTrigger('viewport', createViewportTrigger(parameters, sourceSpan));
                    break;
                default:
                    throw new Error("Unrecognized trigger type \"".concat(identifier, "\""));
            }
        }
        catch (e) {
            this.error(identifier, e.message);
        }
    };
    OnTriggerParser.prototype.consumeParameters = function () {
        var parameters = [];
        if (!this.token().isCharacter(chars.$LPAREN)) {
            this.unexpectedToken(this.token());
            return parameters;
        }
        this.advance();
        var commaDelimStack = [];
        var current = '';
        while (this.index < this.tokens.length) {
            var token = this.token();
            if (token.isCharacter(chars.$RPAREN) && commaDelimStack.length === 0) {
                if (current.length) {
                    parameters.push(current);
                }
                break;
            }
            if (token.type === lexer_1.TokenType.Character && COMMA_DELIMITED_SYNTAX.has(token.numValue)) {
                commaDelimStack.push(COMMA_DELIMITED_SYNTAX.get(token.numValue));
            }
            if (commaDelimStack.length > 0 &&
                token.isCharacter(commaDelimStack[commaDelimStack.length - 1])) {
                commaDelimStack.pop();
            }
            if (commaDelimStack.length === 0 && token.isCharacter(chars.$COMMA) && current.length > 0) {
                parameters.push(current);
                current = '';
                this.advance();
                continue;
            }
            current += this.tokenText();
            this.advance();
        }
        if (!this.token().isCharacter(chars.$RPAREN) || commaDelimStack.length > 0) {
            this.error(this.token(), 'Unexpected end of expression');
        }
        if (this.index < this.tokens.length - 1 &&
            !this.tokens[this.index + 1].isCharacter(chars.$COMMA)) {
            this.unexpectedToken(this.tokens[this.index + 1]);
        }
        return parameters;
    };
    OnTriggerParser.prototype.tokenText = function () {
        return this.expression.slice(this.start + this.token().index, this.start + this.token().end);
    };
    OnTriggerParser.prototype.trackTrigger = function (name, trigger) {
        trackTrigger(name, this.triggers, this.errors, trigger);
    };
    OnTriggerParser.prototype.error = function (token, message) {
        var newStart = this.span.start.moveBy(this.start + token.index);
        var newEnd = newStart.moveBy(token.end - token.index);
        this.errors.push(new parse_util_1.ParseError(new parse_util_1.ParseSourceSpan(newStart, newEnd), message));
    };
    OnTriggerParser.prototype.unexpectedToken = function (token) {
        this.error(token, "Unexpected token \"".concat(token, "\""));
    };
    return OnTriggerParser;
}());
function trackTrigger(name, allTriggers, errors, trigger) {
    if (allTriggers[name]) {
        errors.push(new parse_util_1.ParseError(trigger.sourceSpan, "Duplicate \"".concat(name, "\" trigger is not allowed")));
    }
    else {
        allTriggers[name] = trigger;
    }
}
function createIdleTrigger(parameters, sourceSpan) {
    if (parameters.length > 0) {
        throw new Error("\"".concat(OnTriggerType.IDLE, "\" trigger cannot have parameters"));
    }
    return new t.IdleDeferredTrigger(sourceSpan);
}
function createTimerTrigger(parameters, sourceSpan) {
    if (parameters.length !== 1) {
        throw new Error("\"".concat(OnTriggerType.TIMER, "\" trigger must have exactly one parameter"));
    }
    var delay = parseDeferredTime(parameters[0]);
    if (delay === null) {
        throw new Error("Could not parse time value of trigger \"".concat(OnTriggerType.TIMER, "\""));
    }
    return new t.TimerDeferredTrigger(delay, sourceSpan);
}
function createInteractionTrigger(parameters, sourceSpan) {
    var _a;
    if (parameters.length > 1) {
        throw new Error("\"".concat(OnTriggerType.INTERACTION, "\" trigger can only have zero or one parameters"));
    }
    return new t.InteractionDeferredTrigger((_a = parameters[0]) !== null && _a !== void 0 ? _a : null, sourceSpan);
}
function createImmediateTrigger(parameters, sourceSpan) {
    if (parameters.length > 0) {
        throw new Error("\"".concat(OnTriggerType.IMMEDIATE, "\" trigger cannot have parameters"));
    }
    return new t.ImmediateDeferredTrigger(sourceSpan);
}
function createHoverTrigger(parameters, sourceSpan) {
    if (parameters.length > 0) {
        throw new Error("\"".concat(OnTriggerType.HOVER, "\" trigger cannot have parameters"));
    }
    return new t.HoverDeferredTrigger(sourceSpan);
}
function createViewportTrigger(parameters, sourceSpan) {
    var _a;
    if (parameters.length > 1) {
        throw new Error("\"".concat(OnTriggerType.VIEWPORT, "\" trigger can only have zero or one parameters"));
    }
    return new t.ViewportDeferredTrigger((_a = parameters[0]) !== null && _a !== void 0 ? _a : null, sourceSpan);
}
function getTriggerParametersStart(value, startPosition) {
    if (startPosition === void 0) { startPosition = 0; }
    var hasFoundSeparator = false;
    for (var i = startPosition; i < value.length; i++) {
        if (SEPARATOR_PATTERN.test(value[i])) {
            hasFoundSeparator = true;
        }
        else if (hasFoundSeparator) {
            return i;
        }
    }
    return -1;
}
exports.getTriggerParametersStart = getTriggerParametersStart;
function parseDeferredTime(value) {
    var match = value.match(TIME_PATTERN);
    if (!match) {
        return null;
    }
    var _a = __read(match, 2), time = _a[0], units = _a[1];
    return parseInt(time) * (units === 's' ? 1000 : 1);
}
exports.parseDeferredTime = parseDeferredTime;
