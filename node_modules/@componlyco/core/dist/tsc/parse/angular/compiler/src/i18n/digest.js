"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeMsgId = exports.fingerprint = exports.sha1 = exports.serializeNodes = exports.computeDecimalDigest = exports.decimalDigest = exports.computeDigest = exports.digest = void 0;
var big_integer_1 = require("./big_integer");
var textEncoder;
function digest(message) {
    return message.id || computeDigest(message);
}
exports.digest = digest;
function computeDigest(message) {
    return sha1(serializeNodes(message.nodes).join('') + "[".concat(message.meaning, "]"));
}
exports.computeDigest = computeDigest;
function decimalDigest(message) {
    return message.id || computeDecimalDigest(message);
}
exports.decimalDigest = decimalDigest;
function computeDecimalDigest(message) {
    var visitor = new _SerializerIgnoreIcuExpVisitor();
    var parts = message.nodes.map(function (a) { return a.visit(visitor, null); });
    return computeMsgId(parts.join(''), message.meaning);
}
exports.computeDecimalDigest = computeDecimalDigest;
var _SerializerVisitor = (function () {
    function _SerializerVisitor() {
    }
    _SerializerVisitor.prototype.visitText = function (text, context) {
        return text.value;
    };
    _SerializerVisitor.prototype.visitContainer = function (container, context) {
        var _this = this;
        return "[".concat(container.children.map(function (child) { return child.visit(_this); }).join(', '), "]");
    };
    _SerializerVisitor.prototype.visitIcu = function (icu, context) {
        var _this = this;
        var strCases = Object.keys(icu.cases).map(function (k) { return "".concat(k, " {").concat(icu.cases[k].visit(_this), "}"); });
        return "{".concat(icu.expression, ", ").concat(icu.type, ", ").concat(strCases.join(', '), "}");
    };
    _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {
        var _this = this;
        return ph.isVoid ?
            "<ph tag name=\"".concat(ph.startName, "\"/>") :
            "<ph tag name=\"".concat(ph.startName, "\">").concat(ph.children.map(function (child) { return child.visit(_this); }).join(', '), "</ph name=\"").concat(ph.closeName, "\">");
    };
    _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {
        return ph.value ? "<ph name=\"".concat(ph.name, "\">").concat(ph.value, "</ph>") : "<ph name=\"".concat(ph.name, "\"/>");
    };
    _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
        return "<ph icu name=\"".concat(ph.name, "\">").concat(ph.value.visit(this), "</ph>");
    };
    return _SerializerVisitor;
}());
var serializerVisitor = new _SerializerVisitor();
function serializeNodes(nodes) {
    return nodes.map(function (a) { return a.visit(serializerVisitor, null); });
}
exports.serializeNodes = serializeNodes;
var _SerializerIgnoreIcuExpVisitor = (function (_super) {
    __extends(_SerializerIgnoreIcuExpVisitor, _super);
    function _SerializerIgnoreIcuExpVisitor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {
        var _this = this;
        var strCases = Object.keys(icu.cases).map(function (k) { return "".concat(k, " {").concat(icu.cases[k].visit(_this), "}"); });
        return "{".concat(icu.type, ", ").concat(strCases.join(', '), "}");
    };
    return _SerializerIgnoreIcuExpVisitor;
}(_SerializerVisitor));
function sha1(str) {
    textEncoder !== null && textEncoder !== void 0 ? textEncoder : (textEncoder = new TextEncoder());
    var utf8 = __spreadArray([], __read(textEncoder.encode(str)), false);
    var words32 = bytesToWords32(utf8, Endian.Big);
    var len = utf8.length * 8;
    var w = new Uint32Array(80);
    var a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;
    words32[len >> 5] |= 0x80 << (24 - len % 32);
    words32[((len + 64 >> 9) << 4) + 15] = len;
    for (var i = 0; i < words32.length; i += 16) {
        var h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;
        for (var j = 0; j < 80; j++) {
            if (j < 16) {
                w[j] = words32[i + j];
            }
            else {
                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
            }
            var fkVal = fk(j, b, c, d);
            var f = fkVal[0];
            var k = fkVal[1];
            var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
            e = d;
            d = c;
            c = rol32(b, 30);
            b = a;
            a = temp;
        }
        a = add32(a, h0);
        b = add32(b, h1);
        c = add32(c, h2);
        d = add32(d, h3);
        e = add32(e, h4);
    }
    return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);
}
exports.sha1 = sha1;
function toHexU32(value) {
    return (value >>> 0).toString(16).padStart(8, '0');
}
function fk(index, b, c, d) {
    if (index < 20) {
        return [(b & c) | (~b & d), 0x5a827999];
    }
    if (index < 40) {
        return [b ^ c ^ d, 0x6ed9eba1];
    }
    if (index < 60) {
        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
    }
    return [b ^ c ^ d, 0xca62c1d6];
}
function fingerprint(str) {
    textEncoder !== null && textEncoder !== void 0 ? textEncoder : (textEncoder = new TextEncoder());
    var utf8 = textEncoder.encode(str);
    var view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);
    var hi = hash32(view, utf8.length, 0);
    var lo = hash32(view, utf8.length, 102072);
    if (hi == 0 && (lo == 0 || lo == 1)) {
        hi = hi ^ 0x130f9bef;
        lo = lo ^ -0x6b5f56d8;
    }
    return [hi, lo];
}
exports.fingerprint = fingerprint;
function computeMsgId(msg, meaning) {
    if (meaning === void 0) { meaning = ''; }
    var msgFingerprint = fingerprint(msg);
    if (meaning) {
        var meaningFingerprint = fingerprint(meaning);
        msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
    }
    var hi = msgFingerprint[0];
    var lo = msgFingerprint[1];
    return wordsToDecimalString(hi & 0x7fffffff, lo);
}
exports.computeMsgId = computeMsgId;
function hash32(view, length, c) {
    var a = 0x9e3779b9, b = 0x9e3779b9;
    var index = 0;
    var end = length - 12;
    for (; index <= end; index += 12) {
        a += view.getUint32(index, true);
        b += view.getUint32(index + 4, true);
        c += view.getUint32(index + 8, true);
        var res = mix(a, b, c);
        a = res[0], b = res[1], c = res[2];
    }
    var remainder = length - index;
    c += length;
    if (remainder >= 4) {
        a += view.getUint32(index, true);
        index += 4;
        if (remainder >= 8) {
            b += view.getUint32(index, true);
            index += 4;
            if (remainder >= 9) {
                c += view.getUint8(index++) << 8;
            }
            if (remainder >= 10) {
                c += view.getUint8(index++) << 16;
            }
            if (remainder === 11) {
                c += view.getUint8(index++) << 24;
            }
        }
        else {
            if (remainder >= 5) {
                b += view.getUint8(index++);
            }
            if (remainder >= 6) {
                b += view.getUint8(index++) << 8;
            }
            if (remainder === 7) {
                b += view.getUint8(index++) << 16;
            }
        }
    }
    else {
        if (remainder >= 1) {
            a += view.getUint8(index++);
        }
        if (remainder >= 2) {
            a += view.getUint8(index++) << 8;
        }
        if (remainder === 3) {
            a += view.getUint8(index++) << 16;
        }
    }
    return mix(a, b, c)[2];
}
function mix(a, b, c) {
    a -= b;
    a -= c;
    a ^= c >>> 13;
    b -= c;
    b -= a;
    b ^= a << 8;
    c -= a;
    c -= b;
    c ^= b >>> 13;
    a -= b;
    a -= c;
    a ^= c >>> 12;
    b -= c;
    b -= a;
    b ^= a << 16;
    c -= a;
    c -= b;
    c ^= b >>> 5;
    a -= b;
    a -= c;
    a ^= c >>> 3;
    b -= c;
    b -= a;
    b ^= a << 10;
    c -= a;
    c -= b;
    c ^= b >>> 15;
    return [a, b, c];
}
var Endian;
(function (Endian) {
    Endian[Endian["Little"] = 0] = "Little";
    Endian[Endian["Big"] = 1] = "Big";
})(Endian || (Endian = {}));
function add32(a, b) {
    return add32to64(a, b)[1];
}
function add32to64(a, b) {
    var low = (a & 0xffff) + (b & 0xffff);
    var high = (a >>> 16) + (b >>> 16) + (low >>> 16);
    return [high >>> 16, (high << 16) | (low & 0xffff)];
}
function add64(a, b) {
    var ah = a[0], al = a[1];
    var bh = b[0], bl = b[1];
    var result = add32to64(al, bl);
    var carry = result[0];
    var l = result[1];
    var h = add32(add32(ah, bh), carry);
    return [h, l];
}
function rol32(a, count) {
    return (a << count) | (a >>> (32 - count));
}
function rol64(num, count) {
    var hi = num[0], lo = num[1];
    var h = (hi << count) | (lo >>> (32 - count));
    var l = (lo << count) | (hi >>> (32 - count));
    return [h, l];
}
function bytesToWords32(bytes, endian) {
    var size = (bytes.length + 3) >>> 2;
    var words32 = [];
    for (var i = 0; i < size; i++) {
        words32[i] = wordAt(bytes, i * 4, endian);
    }
    return words32;
}
function byteAt(bytes, index) {
    return index >= bytes.length ? 0 : bytes[index];
}
function wordAt(bytes, index, endian) {
    var word = 0;
    if (endian === Endian.Big) {
        for (var i = 0; i < 4; i++) {
            word += byteAt(bytes, index + i) << (24 - 8 * i);
        }
    }
    else {
        for (var i = 0; i < 4; i++) {
            word += byteAt(bytes, index + i) << 8 * i;
        }
    }
    return word;
}
var base256 = new big_integer_1.BigIntExponentiation(256);
function wordsToDecimalString(hi, lo) {
    var decimal = base256.toThePowerOf(0).multiplyBy(lo);
    base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);
    return decimal.toString();
}
