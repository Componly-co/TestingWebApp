"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createComponentDefinitionMap = exports.compileDeclareComponentFromMetadata = void 0;
var core = __importStar(require("../../core"));
var interpolation_config_1 = require("../../ml_parser/interpolation_config");
var o = __importStar(require("../../output/output_ast"));
var parse_util_1 = require("../../parse_util");
var r3_identifiers_1 = require("../r3_identifiers");
var util_1 = require("../util");
var api_1 = require("../view/api");
var compiler_1 = require("../view/compiler");
var util_2 = require("../view/util");
var directive_1 = require("./directive");
var util_3 = require("./util");
function compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {
    var definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);
    var expression = o.importExpr(r3_identifiers_1.Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);
    var type = (0, compiler_1.createComponentType)(meta);
    return { expression: expression, type: type, statements: [] };
}
exports.compileDeclareComponentFromMetadata = compileDeclareComponentFromMetadata;
function createComponentDefinitionMap(meta, template, templateInfo) {
    var definitionMap = (0, directive_1.createDirectiveDefinitionMap)(meta);
    definitionMap.set('template', getTemplateExpression(template, templateInfo));
    if (templateInfo.isInline) {
        definitionMap.set('isInline', o.literal(true));
    }
    definitionMap.set('styles', (0, util_3.toOptionalLiteralArray)(meta.styles, o.literal));
    definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));
    definitionMap.set('viewProviders', meta.viewProviders);
    definitionMap.set('animations', meta.animations);
    if (meta.changeDetection !== undefined) {
        definitionMap.set('changeDetection', o.importExpr(r3_identifiers_1.Identifiers.ChangeDetectionStrategy)
            .prop(core.ChangeDetectionStrategy[meta.changeDetection]));
    }
    if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {
        definitionMap.set('encapsulation', o.importExpr(r3_identifiers_1.Identifiers.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]));
    }
    if (meta.interpolation !== interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG) {
        definitionMap.set('interpolation', o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]));
    }
    if (template.preserveWhitespaces === true) {
        definitionMap.set('preserveWhitespaces', o.literal(true));
    }
    return definitionMap;
}
exports.createComponentDefinitionMap = createComponentDefinitionMap;
function getTemplateExpression(template, templateInfo) {
    if (templateInfo.inlineTemplateLiteralExpression !== null) {
        return templateInfo.inlineTemplateLiteralExpression;
    }
    if (templateInfo.isInline) {
        return o.literal(templateInfo.content, null, null);
    }
    var contents = templateInfo.content;
    var file = new parse_util_1.ParseSourceFile(contents, templateInfo.sourceUrl);
    var start = new parse_util_1.ParseLocation(file, 0, 0, 0);
    var end = computeEndLocation(file, contents);
    var span = new parse_util_1.ParseSourceSpan(start, end);
    return o.literal(contents, null, span);
}
function computeEndLocation(file, contents) {
    var length = contents.length;
    var lineStart = 0;
    var lastLineStart = 0;
    var line = 0;
    do {
        lineStart = contents.indexOf('\n', lastLineStart);
        if (lineStart !== -1) {
            lastLineStart = lineStart + 1;
            line++;
        }
    } while (lineStart !== -1);
    return new parse_util_1.ParseLocation(file, length, line, length - lastLineStart);
}
function compileUsedDependenciesMetadata(meta) {
    var wrapType = meta.declarationListEmitMode !== 0 ?
        util_1.generateForwardRef :
        function (expr) { return expr; };
    if (meta.declarationListEmitMode === 3) {
        throw new Error("Unsupported emit mode");
    }
    return (0, util_3.toOptionalLiteralArray)(meta.declarations, function (decl) {
        switch (decl.kind) {
            case api_1.R3TemplateDependencyKind.Directive:
                var dirMeta = new util_2.DefinitionMap();
                dirMeta.set('kind', o.literal(decl.isComponent ? 'component' : 'directive'));
                dirMeta.set('type', wrapType(decl.type));
                dirMeta.set('selector', o.literal(decl.selector));
                dirMeta.set('inputs', (0, util_3.toOptionalLiteralArray)(decl.inputs, o.literal));
                dirMeta.set('outputs', (0, util_3.toOptionalLiteralArray)(decl.outputs, o.literal));
                dirMeta.set('exportAs', (0, util_3.toOptionalLiteralArray)(decl.exportAs, o.literal));
                return dirMeta.toLiteralMap();
            case api_1.R3TemplateDependencyKind.Pipe:
                var pipeMeta = new util_2.DefinitionMap();
                pipeMeta.set('kind', o.literal('pipe'));
                pipeMeta.set('type', wrapType(decl.type));
                pipeMeta.set('name', o.literal(decl.name));
                return pipeMeta.toLiteralMap();
            case api_1.R3TemplateDependencyKind.NgModule:
                var ngModuleMeta = new util_2.DefinitionMap();
                ngModuleMeta.set('kind', o.literal('ngmodule'));
                ngModuleMeta.set('type', wrapType(decl.type));
                return ngModuleMeta.toLiteralMap();
        }
    });
}
