"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishFacade = exports.CompilerFacadeImpl = exports.ɵsetEnabledBlockTypes = void 0;
var constant_pool_1 = require("./constant_pool");
var core_1 = require("./core");
var injectable_compiler_2_1 = require("./injectable_compiler_2");
var interpolation_config_1 = require("./ml_parser/interpolation_config");
var output_ast_1 = require("./output/output_ast");
var output_jit_1 = require("./output/output_jit");
var parse_util_1 = require("./parse_util");
var r3_factory_1 = require("./render3/r3_factory");
var r3_injector_compiler_1 = require("./render3/r3_injector_compiler");
var r3_jit_1 = require("./render3/r3_jit");
var r3_module_compiler_1 = require("./render3/r3_module_compiler");
var r3_pipe_compiler_1 = require("./render3/r3_pipe_compiler");
var util_1 = require("./render3/util");
var api_1 = require("./render3/view/api");
var compiler_1 = require("./render3/view/compiler");
var template_1 = require("./render3/view/template");
var resource_loader_1 = require("./resource_loader");
var dom_element_schema_registry_1 = require("./schema/dom_element_schema_registry");
var enabledBlockTypes;
function ɵsetEnabledBlockTypes(types) {
    enabledBlockTypes = types.length > 0 ? new Set(types) : undefined;
}
exports.ɵsetEnabledBlockTypes = ɵsetEnabledBlockTypes;
var CompilerFacadeImpl = (function () {
    function CompilerFacadeImpl(jitEvaluator) {
        if (jitEvaluator === void 0) { jitEvaluator = new output_jit_1.JitEvaluator(); }
        this.jitEvaluator = jitEvaluator;
        this.FactoryTarget = r3_factory_1.FactoryTarget;
        this.ResourceLoader = resource_loader_1.ResourceLoader;
        this.elementSchemaRegistry = new dom_element_schema_registry_1.DomElementSchemaRegistry();
    }
    CompilerFacadeImpl.prototype.compilePipe = function (angularCoreEnv, sourceMapUrl, facade) {
        var metadata = {
            name: facade.name,
            type: (0, util_1.wrapReference)(facade.type),
            typeArgumentCount: 0,
            deps: null,
            pipeName: facade.pipeName,
            pure: facade.pure,
            isStandalone: facade.isStandalone,
        };
        var res = (0, r3_pipe_compiler_1.compilePipeFromMetadata)(metadata);
        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    };
    CompilerFacadeImpl.prototype.compilePipeDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {
        var meta = convertDeclarePipeFacadeToMetadata(declaration);
        var res = (0, r3_pipe_compiler_1.compilePipeFromMetadata)(meta);
        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    };
    CompilerFacadeImpl.prototype.compileInjectable = function (angularCoreEnv, sourceMapUrl, facade) {
        var _a;
        var _b = (0, injectable_compiler_2_1.compileInjectable)({
            name: facade.name,
            type: (0, util_1.wrapReference)(facade.type),
            typeArgumentCount: facade.typeArgumentCount,
            providedIn: computeProvidedIn(facade.providedIn),
            useClass: convertToProviderExpression(facade, 'useClass'),
            useFactory: wrapExpression(facade, 'useFactory'),
            useValue: convertToProviderExpression(facade, 'useValue'),
            useExisting: convertToProviderExpression(facade, 'useExisting'),
            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata),
        }, true), expression = _b.expression, statements = _b.statements;
        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
    };
    CompilerFacadeImpl.prototype.compileInjectableDeclaration = function (angularCoreEnv, sourceMapUrl, facade) {
        var _a;
        var _b = (0, injectable_compiler_2_1.compileInjectable)({
            name: facade.type.name,
            type: (0, util_1.wrapReference)(facade.type),
            typeArgumentCount: 0,
            providedIn: computeProvidedIn(facade.providedIn),
            useClass: convertToProviderExpression(facade, 'useClass'),
            useFactory: wrapExpression(facade, 'useFactory'),
            useValue: convertToProviderExpression(facade, 'useValue'),
            useExisting: convertToProviderExpression(facade, 'useExisting'),
            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata),
        }, true), expression = _b.expression, statements = _b.statements;
        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
    };
    CompilerFacadeImpl.prototype.compileInjector = function (angularCoreEnv, sourceMapUrl, facade) {
        var meta = {
            name: facade.name,
            type: (0, util_1.wrapReference)(facade.type),
            providers: facade.providers && facade.providers.length > 0 ?
                new output_ast_1.WrappedNodeExpr(facade.providers) :
                null,
            imports: facade.imports.map(function (i) { return new output_ast_1.WrappedNodeExpr(i); }),
        };
        var res = (0, r3_injector_compiler_1.compileInjector)(meta);
        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    };
    CompilerFacadeImpl.prototype.compileInjectorDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {
        var meta = convertDeclareInjectorFacadeToMetadata(declaration);
        var res = (0, r3_injector_compiler_1.compileInjector)(meta);
        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    };
    CompilerFacadeImpl.prototype.compileNgModule = function (angularCoreEnv, sourceMapUrl, facade) {
        var meta = {
            kind: r3_module_compiler_1.R3NgModuleMetadataKind.Global,
            type: (0, util_1.wrapReference)(facade.type),
            bootstrap: facade.bootstrap.map(util_1.wrapReference),
            declarations: facade.declarations.map(util_1.wrapReference),
            publicDeclarationTypes: null,
            imports: facade.imports.map(util_1.wrapReference),
            includeImportTypes: true,
            exports: facade.exports.map(util_1.wrapReference),
            selectorScopeMode: r3_module_compiler_1.R3SelectorScopeMode.Inline,
            containsForwardDecls: false,
            schemas: facade.schemas ? facade.schemas.map(util_1.wrapReference) : null,
            id: facade.id ? new output_ast_1.WrappedNodeExpr(facade.id) : null,
        };
        var res = (0, r3_module_compiler_1.compileNgModule)(meta);
        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    };
    CompilerFacadeImpl.prototype.compileNgModuleDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {
        var expression = (0, r3_module_compiler_1.compileNgModuleDeclarationExpression)(declaration);
        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);
    };
    CompilerFacadeImpl.prototype.compileDirective = function (angularCoreEnv, sourceMapUrl, facade) {
        var meta = convertDirectiveFacadeToMetadata(facade);
        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
    };
    CompilerFacadeImpl.prototype.compileDirectiveDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {
        var typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);
        var meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);
        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
    };
    CompilerFacadeImpl.prototype.compileDirectiveFromMeta = function (angularCoreEnv, sourceMapUrl, meta) {
        var constantPool = new constant_pool_1.ConstantPool();
        var bindingParser = (0, template_1.makeBindingParser)();
        var res = (0, compiler_1.compileDirectiveFromMetadata)(meta, constantPool, bindingParser);
        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
    };
    CompilerFacadeImpl.prototype.compileComponent = function (angularCoreEnv, sourceMapUrl, facade) {
        var _a = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation), template = _a.template, interpolation = _a.interpolation;
        var meta = __assign(__assign(__assign({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template: template, declarations: facade.declarations.map(convertDeclarationFacadeToMetadata), declarationListEmitMode: 0, deferBlocks: new Map(), deferrableDeclToImportDecl: new Map(), styles: __spreadArray(__spreadArray([], __read(facade.styles), false), __read(template.styles), false), encapsulation: facade.encapsulation, interpolation: interpolation, changeDetection: facade.changeDetection, animations: facade.animations != null ? new output_ast_1.WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new output_ast_1.WrappedNodeExpr(facade.viewProviders) :
                null, relativeContextFilePath: '', i18nUseExternalIds: true });
        var jitExpressionSourceMap = "ng:///".concat(facade.name, ".js");
        return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);
    };
    CompilerFacadeImpl.prototype.compileComponentDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {
        var typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);
        var meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);
        return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);
    };
    CompilerFacadeImpl.prototype.compileComponentFromMeta = function (angularCoreEnv, sourceMapUrl, meta) {
        var constantPool = new constant_pool_1.ConstantPool();
        var bindingParser = (0, template_1.makeBindingParser)(meta.interpolation);
        var res = (0, compiler_1.compileComponentFromMetadata)(meta, constantPool, bindingParser);
        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
    };
    CompilerFacadeImpl.prototype.compileFactory = function (angularCoreEnv, sourceMapUrl, meta) {
        var factoryRes = (0, r3_factory_1.compileFactoryFunction)({
            name: meta.name,
            type: (0, util_1.wrapReference)(meta.type),
            typeArgumentCount: meta.typeArgumentCount,
            deps: convertR3DependencyMetadataArray(meta.deps),
            target: meta.target,
        });
        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
    };
    CompilerFacadeImpl.prototype.compileFactoryDeclaration = function (angularCoreEnv, sourceMapUrl, meta) {
        var factoryRes = (0, r3_factory_1.compileFactoryFunction)({
            name: meta.type.name,
            type: (0, util_1.wrapReference)(meta.type),
            typeArgumentCount: 0,
            deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :
                meta.deps,
            target: meta.target,
        });
        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
    };
    CompilerFacadeImpl.prototype.createParseSourceSpan = function (kind, typeName, sourceUrl) {
        return (0, parse_util_1.r3JitTypeSourceSpan)(kind, typeName, sourceUrl);
    };
    CompilerFacadeImpl.prototype.jitExpression = function (def, context, sourceUrl, preStatements) {
        var statements = __spreadArray(__spreadArray([], __read(preStatements), false), [
            new output_ast_1.DeclareVarStmt('$def', def, undefined, output_ast_1.StmtModifier.Exported),
        ], false);
        var res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new r3_jit_1.R3JitReflector(context), true);
        return res['$def'];
    };
    return CompilerFacadeImpl;
}());
exports.CompilerFacadeImpl = CompilerFacadeImpl;
function convertToR3QueryMetadata(facade) {
    return __assign(__assign({}, facade), { predicate: convertQueryPredicate(facade.predicate), read: facade.read ? new output_ast_1.WrappedNodeExpr(facade.read) : null, static: facade.static, emitDistinctChangesOnly: facade.emitDistinctChangesOnly });
}
function convertQueryDeclarationToMetadata(declaration) {
    var _a, _b, _c, _d;
    return {
        propertyName: declaration.propertyName,
        first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,
        predicate: convertQueryPredicate(declaration.predicate),
        descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,
        read: declaration.read ? new output_ast_1.WrappedNodeExpr(declaration.read) : null,
        static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,
        emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true,
    };
}
function convertQueryPredicate(predicate) {
    return Array.isArray(predicate) ?
        predicate :
        (0, util_1.createMayBeForwardRefExpression)(new output_ast_1.WrappedNodeExpr(predicate), 1);
}
function convertDirectiveFacadeToMetadata(facade) {
    var inputsFromMetadata = parseInputsArray(facade.inputs || []);
    var outputsFromMetadata = parseMappingStringArray(facade.outputs || []);
    var propMetadata = facade.propMetadata;
    var inputsFromType = {};
    var outputsFromType = {};
    var _loop_1 = function (field) {
        if (propMetadata.hasOwnProperty(field)) {
            propMetadata[field].forEach(function (ann) {
                if (isInput(ann)) {
                    inputsFromType[field] = {
                        bindingPropertyName: ann.alias || field,
                        classPropertyName: field,
                        required: ann.required || false,
                        transformFunction: ann.transform != null ? new output_ast_1.WrappedNodeExpr(ann.transform) : null,
                    };
                }
                else if (isOutput(ann)) {
                    outputsFromType[field] = ann.alias || field;
                }
            });
        }
    };
    for (var field in propMetadata) {
        _loop_1(field);
    }
    return __assign(__assign({}, facade), { typeArgumentCount: 0, typeSourceSpan: facade.typeSourceSpan, type: (0, util_1.wrapReference)(facade.type), deps: null, host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: __assign(__assign({}, inputsFromMetadata), inputsFromType), outputs: __assign(__assign({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new output_ast_1.WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false, hostDirectives: convertHostDirectivesToMetadata(facade) });
}
function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return {
        name: declaration.type.name,
        type: (0, util_1.wrapReference)(declaration.type),
        typeSourceSpan: typeSourceSpan,
        selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,
        inputs: declaration.inputs ? inputsMappingToInputMetadata(declaration.inputs) : {},
        outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : {},
        host: convertHostDeclarationToMetadata(declaration.host),
        queries: ((_c = declaration.queries) !== null && _c !== void 0 ? _c : []).map(convertQueryDeclarationToMetadata),
        viewQueries: ((_d = declaration.viewQueries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),
        providers: declaration.providers !== undefined ? new output_ast_1.WrappedNodeExpr(declaration.providers) :
            null,
        exportAs: (_e = declaration.exportAs) !== null && _e !== void 0 ? _e : null,
        usesInheritance: (_f = declaration.usesInheritance) !== null && _f !== void 0 ? _f : false,
        lifecycle: { usesOnChanges: (_g = declaration.usesOnChanges) !== null && _g !== void 0 ? _g : false },
        deps: null,
        typeArgumentCount: 0,
        fullInheritance: false,
        isStandalone: (_h = declaration.isStandalone) !== null && _h !== void 0 ? _h : false,
        isSignal: (_j = declaration.isSignal) !== null && _j !== void 0 ? _j : false,
        hostDirectives: convertHostDirectivesToMetadata(declaration),
    };
}
function convertHostDeclarationToMetadata(host) {
    var _a, _b, _c;
    if (host === void 0) { host = {}; }
    return {
        attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),
        listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},
        properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},
        specialAttributes: {
            classAttr: host.classAttribute,
            styleAttr: host.styleAttribute,
        },
    };
}
function convertHostDirectivesToMetadata(metadata) {
    var _a;
    if ((_a = metadata.hostDirectives) === null || _a === void 0 ? void 0 : _a.length) {
        return metadata.hostDirectives.map(function (hostDirective) {
            return typeof hostDirective === 'function' ?
                {
                    directive: (0, util_1.wrapReference)(hostDirective),
                    inputs: null,
                    outputs: null,
                    isForwardReference: false
                } :
                {
                    directive: (0, util_1.wrapReference)(hostDirective.directive),
                    isForwardReference: false,
                    inputs: hostDirective.inputs ? parseMappingStringArray(hostDirective.inputs) : null,
                    outputs: hostDirective.outputs ? parseMappingStringArray(hostDirective.outputs) : null,
                };
        });
    }
    return null;
}
function convertOpaqueValuesToExpressions(obj) {
    var e_1, _a;
    var result = {};
    try {
        for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            result[key] = new output_ast_1.WrappedNodeExpr(obj[key]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
function convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {
    var e_2, _a;
    var _b, _c, _d, _e;
    var _f = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, (_b = decl.preserveWhitespaces) !== null && _b !== void 0 ? _b : false, decl.interpolation), template = _f.template, interpolation = _f.interpolation;
    var declarations = [];
    if (decl.dependencies) {
        try {
            for (var _g = __values(decl.dependencies), _h = _g.next(); !_h.done; _h = _g.next()) {
                var innerDep = _h.value;
                switch (innerDep.kind) {
                    case 'directive':
                    case 'component':
                        declarations.push(convertDirectiveDeclarationToMetadata(innerDep));
                        break;
                    case 'pipe':
                        declarations.push(convertPipeDeclarationToMetadata(innerDep));
                        break;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    else if (decl.components || decl.directives || decl.pipes) {
        decl.components && declarations.push.apply(declarations, __spreadArray([], __read(decl.components.map(function (dir) { return convertDirectiveDeclarationToMetadata(dir, true); })), false));
        decl.directives && declarations.push.apply(declarations, __spreadArray([], __read(decl.directives.map(function (dir) { return convertDirectiveDeclarationToMetadata(dir); })), false));
        decl.pipes && declarations.push.apply(declarations, __spreadArray([], __read(convertPipeMapToMetadata(decl.pipes)), false));
    }
    return __assign(__assign({}, convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan)), { template: template, styles: (_c = decl.styles) !== null && _c !== void 0 ? _c : [], declarations: declarations, viewProviders: decl.viewProviders !== undefined ? new output_ast_1.WrappedNodeExpr(decl.viewProviders) :
            null, animations: decl.animations !== undefined ? new output_ast_1.WrappedNodeExpr(decl.animations) : null, deferBlocks: new Map(), deferrableDeclToImportDecl: new Map(), changeDetection: (_d = decl.changeDetection) !== null && _d !== void 0 ? _d : core_1.ChangeDetectionStrategy.Default, encapsulation: (_e = decl.encapsulation) !== null && _e !== void 0 ? _e : core_1.ViewEncapsulation.Emulated, interpolation: interpolation, declarationListEmitMode: 2, relativeContextFilePath: '', i18nUseExternalIds: true });
}
function convertDeclarationFacadeToMetadata(declaration) {
    return __assign(__assign({}, declaration), { type: new output_ast_1.WrappedNodeExpr(declaration.type) });
}
function convertDirectiveDeclarationToMetadata(declaration, isComponent) {
    var _a, _b, _c;
    if (isComponent === void 0) { isComponent = null; }
    return {
        kind: api_1.R3TemplateDependencyKind.Directive,
        isComponent: isComponent || declaration.kind === 'component',
        selector: declaration.selector,
        type: new output_ast_1.WrappedNodeExpr(declaration.type),
        inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],
        outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],
        exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null,
    };
}
function convertPipeMapToMetadata(pipes) {
    if (!pipes) {
        return [];
    }
    return Object.keys(pipes).map(function (name) {
        return {
            kind: api_1.R3TemplateDependencyKind.Pipe,
            name: name,
            type: new output_ast_1.WrappedNodeExpr(pipes[name]),
        };
    });
}
function convertPipeDeclarationToMetadata(pipe) {
    return {
        kind: api_1.R3TemplateDependencyKind.Pipe,
        name: pipe.name,
        type: new output_ast_1.WrappedNodeExpr(pipe.type),
    };
}
function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {
    var interpolationConfig = interpolation ? interpolation_config_1.InterpolationConfig.fromArray(interpolation) : interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
    var parsed = (0, template_1.parseTemplate)(template, sourceMapUrl, { preserveWhitespaces: preserveWhitespaces, interpolationConfig: interpolationConfig, enabledBlockTypes: enabledBlockTypes });
    if (parsed.errors !== null) {
        var errors = parsed.errors.map(function (err) { return err.toString(); }).join(', ');
        throw new Error("Errors during JIT compilation of template for ".concat(typeName, ": ").concat(errors));
    }
    return { template: parsed, interpolation: interpolationConfig };
}
function convertToProviderExpression(obj, property) {
    if (obj.hasOwnProperty(property)) {
        return (0, util_1.createMayBeForwardRefExpression)(new output_ast_1.WrappedNodeExpr(obj[property]), 0);
    }
    else {
        return undefined;
    }
}
function wrapExpression(obj, property) {
    if (obj.hasOwnProperty(property)) {
        return new output_ast_1.WrappedNodeExpr(obj[property]);
    }
    else {
        return undefined;
    }
}
function computeProvidedIn(providedIn) {
    var expression = typeof providedIn === 'function' ? new output_ast_1.WrappedNodeExpr(providedIn) :
        new output_ast_1.LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null);
    return (0, util_1.createMayBeForwardRefExpression)(expression, 0);
}
function convertR3DependencyMetadataArray(facades) {
    return facades == null ? null : facades.map(convertR3DependencyMetadata);
}
function convertR3DependencyMetadata(facade) {
    var isAttributeDep = facade.attribute != null;
    var rawToken = facade.token === null ? null : new output_ast_1.WrappedNodeExpr(facade.token);
    var token = isAttributeDep ? new output_ast_1.WrappedNodeExpr(facade.attribute) : rawToken;
    return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);
}
function convertR3DeclareDependencyMetadata(facade) {
    var _a, _b, _c, _d, _e;
    var isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;
    var token = facade.token === null ? null : new output_ast_1.WrappedNodeExpr(facade.token);
    return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);
}
function createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {
    var attributeNameType = isAttributeDep ? (0, output_ast_1.literal)('unknown') : null;
    return { token: token, attributeNameType: attributeNameType, host: host, optional: optional, self: self, skipSelf: skipSelf };
}
function extractHostBindings(propMetadata, sourceSpan, host) {
    var bindings = (0, compiler_1.parseHostBindings)(host || {});
    var errors = (0, compiler_1.verifyHostBindings)(bindings, sourceSpan);
    if (errors.length) {
        throw new Error(errors.map(function (error) { return error.msg; }).join('\n'));
    }
    var _loop_2 = function (field) {
        if (propMetadata.hasOwnProperty(field)) {
            propMetadata[field].forEach(function (ann) {
                if (isHostBinding(ann)) {
                    bindings.properties[ann.hostPropertyName || field] =
                        (0, util_1.getSafePropertyAccessString)('this', field);
                }
                else if (isHostListener(ann)) {
                    bindings.listeners[ann.eventName || field] = "".concat(field, "(").concat((ann.args || []).join(','), ")");
                }
            });
        }
    };
    for (var field in propMetadata) {
        _loop_2(field);
    }
    return bindings;
}
function isHostBinding(value) {
    return value.ngMetadataName === 'HostBinding';
}
function isHostListener(value) {
    return value.ngMetadataName === 'HostListener';
}
function isInput(value) {
    return value.ngMetadataName === 'Input';
}
function isOutput(value) {
    return value.ngMetadataName === 'Output';
}
function inputsMappingToInputMetadata(inputs) {
    return Object.keys(inputs).reduce(function (result, key) {
        var value = inputs[key];
        if (typeof value === 'string') {
            result[key] = {
                bindingPropertyName: value,
                classPropertyName: value,
                transformFunction: null,
                required: false,
            };
        }
        else {
            result[key] = {
                bindingPropertyName: value[0],
                classPropertyName: value[1],
                transformFunction: value[2] ? new output_ast_1.WrappedNodeExpr(value[2]) : null,
                required: false,
            };
        }
        return result;
    }, {});
}
function parseInputsArray(values) {
    return values.reduce(function (results, value) {
        if (typeof value === 'string') {
            var _a = __read(parseMappingString(value), 2), bindingPropertyName = _a[0], classPropertyName = _a[1];
            results[classPropertyName] = {
                bindingPropertyName: bindingPropertyName,
                classPropertyName: classPropertyName,
                required: false,
                transformFunction: null,
            };
        }
        else {
            results[value.name] = {
                bindingPropertyName: value.alias || value.name,
                classPropertyName: value.name,
                required: value.required || false,
                transformFunction: value.transform != null ? new output_ast_1.WrappedNodeExpr(value.transform) : null,
            };
        }
        return results;
    }, {});
}
function parseMappingStringArray(values) {
    return values.reduce(function (results, value) {
        var _a = __read(parseMappingString(value), 2), alias = _a[0], fieldName = _a[1];
        results[fieldName] = alias;
        return results;
    }, {});
}
function parseMappingString(value) {
    var _a = __read(value.split(':', 2).map(function (str) { return str.trim(); }), 2), fieldName = _a[0], bindingPropertyName = _a[1];
    return [bindingPropertyName !== null && bindingPropertyName !== void 0 ? bindingPropertyName : fieldName, fieldName];
}
function convertDeclarePipeFacadeToMetadata(declaration) {
    var _a, _b;
    return {
        name: declaration.type.name,
        type: (0, util_1.wrapReference)(declaration.type),
        typeArgumentCount: 0,
        pipeName: declaration.name,
        deps: null,
        pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,
        isStandalone: (_b = declaration.isStandalone) !== null && _b !== void 0 ? _b : false,
    };
}
function convertDeclareInjectorFacadeToMetadata(declaration) {
    return {
        name: declaration.type.name,
        type: (0, util_1.wrapReference)(declaration.type),
        providers: declaration.providers !== undefined && declaration.providers.length > 0 ?
            new output_ast_1.WrappedNodeExpr(declaration.providers) :
            null,
        imports: declaration.imports !== undefined ?
            declaration.imports.map(function (i) { return new output_ast_1.WrappedNodeExpr(i); }) :
            [],
    };
}
function publishFacade(global) {
    var ng = global.ng || (global.ng = {});
    ng.ɵcompilerFacade = new CompilerFacadeImpl();
}
exports.publishFacade = publishFacade;
