"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.htmlAstToRender3Ast = void 0;
var html = __importStar(require("../ml_parser/ast"));
var html_whitespaces_1 = require("../ml_parser/html_whitespaces");
var tags_1 = require("../ml_parser/tags");
var parse_util_1 = require("../parse_util");
var style_url_resolver_1 = require("../style_url_resolver");
var template_preparser_1 = require("../template_parser/template_preparser");
var t = __importStar(require("./r3_ast"));
var r3_control_flow_1 = require("./r3_control_flow");
var r3_deferred_blocks_1 = require("./r3_deferred_blocks");
var util_1 = require("./view/i18n/util");
var BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;
var KW_BIND_IDX = 1;
var KW_LET_IDX = 2;
var KW_REF_IDX = 3;
var KW_ON_IDX = 4;
var KW_BINDON_IDX = 5;
var KW_AT_IDX = 6;
var IDENT_KW_IDX = 7;
var BINDING_DELIMS = {
    BANANA_BOX: { start: '[(', end: ')]' },
    PROPERTY: { start: '[', end: ']' },
    EVENT: { start: '(', end: ')' },
};
var TEMPLATE_ATTR_PREFIX = '*';
function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {
    var transformer = new HtmlAstToIvyAst(bindingParser, options);
    var ivyNodes = html.visitAll(transformer, htmlNodes);
    var allErrors = bindingParser.errors.concat(transformer.errors);
    var result = {
        nodes: ivyNodes,
        errors: allErrors,
        styleUrls: transformer.styleUrls,
        styles: transformer.styles,
        ngContentSelectors: transformer.ngContentSelectors
    };
    if (options.collectCommentNodes) {
        result.commentNodes = transformer.commentNodes;
    }
    return result;
}
exports.htmlAstToRender3Ast = htmlAstToRender3Ast;
var HtmlAstToIvyAst = (function () {
    function HtmlAstToIvyAst(bindingParser, options) {
        this.bindingParser = bindingParser;
        this.options = options;
        this.errors = [];
        this.styles = [];
        this.styleUrls = [];
        this.ngContentSelectors = [];
        this.commentNodes = [];
        this.inI18nBlock = false;
    }
    HtmlAstToIvyAst.prototype.visitElement = function (element) {
        var e_1, _a;
        var _this = this;
        var isI18nRootElement = (0, util_1.isI18nRootNode)(element.i18n);
        if (isI18nRootElement) {
            if (this.inI18nBlock) {
                this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);
            }
            this.inI18nBlock = true;
        }
        var preparsedElement = (0, template_preparser_1.preparseElement)(element);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT) {
            return null;
        }
        else if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE) {
            var contents = textContents(element);
            if (contents !== null) {
                this.styles.push(contents);
            }
            return null;
        }
        else if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET &&
            (0, style_url_resolver_1.isStyleUrlResolvable)(preparsedElement.hrefAttr)) {
            this.styleUrls.push(preparsedElement.hrefAttr);
            return null;
        }
        var isTemplateElement = (0, tags_1.isNgTemplate)(element.name);
        var parsedProperties = [];
        var boundEvents = [];
        var variables = [];
        var references = [];
        var attributes = [];
        var i18nAttrsMeta = {};
        var templateParsedProperties = [];
        var templateVariables = [];
        var elementHasInlineTemplate = false;
        try {
            for (var _b = __values(element.attrs), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attribute = _c.value;
                var hasBinding = false;
                var normalizedName = normalizeAttributeName(attribute.name);
                var isTemplateBinding = false;
                if (attribute.i18n) {
                    i18nAttrsMeta[attribute.name] = attribute.i18n;
                }
                if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
                    if (elementHasInlineTemplate) {
                        this.reportError("Can't have multiple template bindings on one element. Use only one attribute prefixed with *", attribute.sourceSpan);
                    }
                    isTemplateBinding = true;
                    elementHasInlineTemplate = true;
                    var templateValue = attribute.value;
                    var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);
                    var parsedVariables = [];
                    var absoluteValueOffset = attribute.valueSpan ?
                        attribute.valueSpan.start.offset :
                        attribute.sourceSpan.start.offset + attribute.name.length;
                    this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true);
                    templateVariables.push.apply(templateVariables, __spreadArray([], __read(parsedVariables.map(function (v) { return new t.Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan); })), false));
                }
                else {
                    hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);
                }
                if (!hasBinding && !isTemplateBinding) {
                    attributes.push(this.visitAttribute(attribute));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var children;
        if (preparsedElement.nonBindable) {
            children = html.visitAll(NON_BINDABLE_VISITOR, element.children).flat(Infinity);
        }
        else {
            children = html.visitAll(this, element.children);
        }
        var parsedElement;
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {
            if (element.children &&
                !element.children.every(function (node) { return isEmptyTextNode(node) || isCommentNode(node); })) {
                this.reportError("<ng-content> element cannot have content.", element.sourceSpan);
            }
            var selector = preparsedElement.selectAttr;
            var attrs = element.attrs.map(function (attr) { return _this.visitAttribute(attr); });
            parsedElement = new t.Content(selector, attrs, element.sourceSpan, element.i18n);
            this.ngContentSelectors.push(selector);
        }
        else if (isTemplateElement) {
            var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
            parsedElement = new t.Template(element.name, attributes, attrs.bound, boundEvents, [], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
        else {
            var attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
            parsedElement = new t.Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
        if (elementHasInlineTemplate) {
            var attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);
            var templateAttrs_1 = [];
            attrs.literal.forEach(function (attr) { return templateAttrs_1.push(attr); });
            attrs.bound.forEach(function (attr) { return templateAttrs_1.push(attr); });
            var hoistedAttrs = parsedElement instanceof t.Element ?
                {
                    attributes: parsedElement.attributes,
                    inputs: parsedElement.inputs,
                    outputs: parsedElement.outputs,
                } :
                { attributes: [], inputs: [], outputs: [] };
            var i18n_1 = isTemplateElement && isI18nRootElement ? undefined : element.i18n;
            var name_1 = parsedElement instanceof t.Template ? null : parsedElement.name;
            parsedElement = new t.Template(name_1, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs_1, [parsedElement], [], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n_1);
        }
        if (isI18nRootElement) {
            this.inI18nBlock = false;
        }
        return parsedElement;
    };
    HtmlAstToIvyAst.prototype.visitAttribute = function (attribute) {
        return new t.TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    };
    HtmlAstToIvyAst.prototype.visitText = function (text) {
        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);
    };
    HtmlAstToIvyAst.prototype.visitExpansion = function (expansion) {
        var _this = this;
        if (!expansion.i18n) {
            return null;
        }
        if (!(0, util_1.isI18nRootNode)(expansion.i18n)) {
            throw new Error("Invalid type \"".concat(expansion.i18n.constructor, "\" for \"i18n\" property of ").concat(expansion.sourceSpan.toString(), ". Expected a \"Message\""));
        }
        var message = expansion.i18n;
        var vars = {};
        var placeholders = {};
        Object.keys(message.placeholders).forEach(function (key) {
            var value = message.placeholders[key];
            if (key.startsWith(util_1.I18N_ICU_VAR_PREFIX)) {
                var formattedKey = key.trim();
                var ast = _this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);
                vars[formattedKey] = new t.BoundText(ast, value.sourceSpan);
            }
            else {
                placeholders[key] = _this._visitTextWithInterpolation(value.text, value.sourceSpan, null);
            }
        });
        return new t.Icu(vars, placeholders, expansion.sourceSpan, message);
    };
    HtmlAstToIvyAst.prototype.visitExpansionCase = function (expansionCase) {
        return null;
    };
    HtmlAstToIvyAst.prototype.visitComment = function (comment) {
        if (this.options.collectCommentNodes) {
            this.commentNodes.push(new t.Comment(comment.value || '', comment.sourceSpan));
        }
        return null;
    };
    HtmlAstToIvyAst.prototype.visitBlockGroup = function (group, context) {
        var _a;
        var primaryBlock = group.blocks[0];
        if (!primaryBlock) {
            this.reportError('Block group must have at least one block.', group.sourceSpan);
            return null;
        }
        if (!this.options.enabledBlockTypes.has(primaryBlock.name)) {
            this.reportError("Unrecognized block \"".concat(primaryBlock.name, "\"."), primaryBlock.sourceSpan);
            return null;
        }
        var result = null;
        switch (primaryBlock.name) {
            case 'defer':
                result = (0, r3_deferred_blocks_1.createDeferredBlock)(group, this, this.bindingParser);
                break;
            case 'switch':
                result = (0, r3_control_flow_1.createSwitchBlock)(group, this, this.bindingParser);
                break;
            case 'for':
                result = (0, r3_control_flow_1.createForLoop)(group, this, this.bindingParser);
                break;
            case 'if':
                result = (0, r3_control_flow_1.createIfBlock)(group, this, this.bindingParser);
                break;
            default:
                result = {
                    node: null,
                    errors: [new parse_util_1.ParseError(primaryBlock.sourceSpan, "Unrecognized block \"".concat(primaryBlock.name, "\"."))]
                };
                break;
        }
        (_a = this.errors).push.apply(_a, __spreadArray([], __read(result.errors), false));
        return result.node;
    };
    HtmlAstToIvyAst.prototype.visitBlock = function (block, context) { };
    HtmlAstToIvyAst.prototype.visitBlockParameter = function (parameter, context) { };
    HtmlAstToIvyAst.prototype.extractAttributes = function (elementName, properties, i18nPropsMeta) {
        var _this = this;
        var bound = [];
        var literal = [];
        properties.forEach(function (prop) {
            var i18n = i18nPropsMeta[prop.name];
            if (prop.isLiteral) {
                literal.push(new t.TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));
            }
            else {
                var bep = _this.bindingParser.createBoundElementProperty(elementName, prop, true, false);
                bound.push(t.BoundAttribute.fromBoundElementProperty(bep, i18n));
            }
        });
        return { bound: bound, literal: literal };
    };
    HtmlAstToIvyAst.prototype.parseAttribute = function (isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
        var _a;
        var name = normalizeAttributeName(attribute.name);
        var value = attribute.value;
        var srcSpan = attribute.sourceSpan;
        var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
        function createKeySpan(srcSpan, prefix, identifier) {
            var normalizationAdjustment = attribute.name.length - name.length;
            var keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);
            var keySpanEnd = keySpanStart.moveBy(identifier.length);
            return new parse_util_1.ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);
        }
        var bindParts = name.match(BIND_NAME_REGEXP);
        if (bindParts) {
            if (bindParts[KW_BIND_IDX] != null) {
                var identifier = bindParts[IDENT_KW_IDX];
                var keySpan_1 = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);
                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_1);
            }
            else if (bindParts[KW_LET_IDX]) {
                if (isTemplateElement) {
                    var identifier = bindParts[IDENT_KW_IDX];
                    var keySpan_2 = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);
                    this.parseVariable(identifier, value, srcSpan, keySpan_2, attribute.valueSpan, variables);
                }
                else {
                    this.reportError("\"let-\" is only supported on ng-template elements.", srcSpan);
                }
            }
            else if (bindParts[KW_REF_IDX]) {
                var identifier = bindParts[IDENT_KW_IDX];
                var keySpan_3 = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);
                this.parseReference(identifier, value, srcSpan, keySpan_3, attribute.valueSpan, references);
            }
            else if (bindParts[KW_ON_IDX]) {
                var events = [];
                var identifier = bindParts[IDENT_KW_IDX];
                var keySpan_4 = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);
                this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan_4);
                addEvents(events, boundEvents);
            }
            else if (bindParts[KW_BINDON_IDX]) {
                var identifier = bindParts[IDENT_KW_IDX];
                var keySpan_5 = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);
                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_5);
                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan_5);
            }
            else if (bindParts[KW_AT_IDX]) {
                var keySpan_6 = createKeySpan(srcSpan, '', name);
                this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_6);
            }
            return true;
        }
        var delims = null;
        if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {
            delims = BINDING_DELIMS.BANANA_BOX;
        }
        else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {
            delims = BINDING_DELIMS.PROPERTY;
        }
        else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {
            delims = BINDING_DELIMS.EVENT;
        }
        if (delims !== null &&
            name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {
            var identifier = name.substring(delims.start.length, name.length - delims.end.length);
            var keySpan_7 = createKeySpan(srcSpan, delims.start, identifier);
            if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {
                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_7);
                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan_7);
            }
            else if (delims.start === BINDING_DELIMS.PROPERTY.start) {
                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan_7);
            }
            else {
                var events = [];
                this.bindingParser.parseEvent(identifier, value, false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan_7);
                addEvents(events, boundEvents);
            }
            return true;
        }
        var keySpan = createKeySpan(srcSpan, '', name);
        var hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, (_a = attribute.valueTokens) !== null && _a !== void 0 ? _a : null);
        return hasBinding;
    };
    HtmlAstToIvyAst.prototype._visitTextWithInterpolation = function (value, sourceSpan, interpolatedTokens, i18n) {
        var valueNoNgsp = (0, html_whitespaces_1.replaceNgsp)(value);
        var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);
        return expr ? new t.BoundText(expr, sourceSpan, i18n) : new t.Text(valueNoNgsp, sourceSpan);
    };
    HtmlAstToIvyAst.prototype.parseVariable = function (identifier, value, sourceSpan, keySpan, valueSpan, variables) {
        if (identifier.indexOf('-') > -1) {
            this.reportError("\"-\" is not allowed in variable names", sourceSpan);
        }
        else if (identifier.length === 0) {
            this.reportError("Variable does not have a name", sourceSpan);
        }
        variables.push(new t.Variable(identifier, value, sourceSpan, keySpan, valueSpan));
    };
    HtmlAstToIvyAst.prototype.parseReference = function (identifier, value, sourceSpan, keySpan, valueSpan, references) {
        if (identifier.indexOf('-') > -1) {
            this.reportError("\"-\" is not allowed in reference names", sourceSpan);
        }
        else if (identifier.length === 0) {
            this.reportError("Reference does not have a name", sourceSpan);
        }
        else if (references.some(function (reference) { return reference.name === identifier; })) {
            this.reportError("Reference \"#".concat(identifier, "\" is defined more than once"), sourceSpan);
        }
        references.push(new t.Reference(identifier, value, sourceSpan, keySpan, valueSpan));
    };
    HtmlAstToIvyAst.prototype.parseAssignmentEvent = function (name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {
        var events = [];
        this.bindingParser.parseEvent("".concat(name, "Change"), "".concat(expression, " =$event"), true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);
        addEvents(events, boundEvents);
    };
    HtmlAstToIvyAst.prototype.reportError = function (message, sourceSpan, level) {
        if (level === void 0) { level = parse_util_1.ParseErrorLevel.ERROR; }
        this.errors.push(new parse_util_1.ParseError(sourceSpan, message, level));
    };
    return HtmlAstToIvyAst;
}());
var NonBindableVisitor = (function () {
    function NonBindableVisitor() {
    }
    NonBindableVisitor.prototype.visitElement = function (ast) {
        var preparsedElement = (0, template_preparser_1.preparseElement)(ast);
        if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE ||
            preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {
            return null;
        }
        var children = html.visitAll(this, ast.children, null);
        return new t.Element(ast.name, html.visitAll(this, ast.attrs), [], [], children, [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
    };
    NonBindableVisitor.prototype.visitComment = function (comment) {
        return null;
    };
    NonBindableVisitor.prototype.visitAttribute = function (attribute) {
        return new t.TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    };
    NonBindableVisitor.prototype.visitText = function (text) {
        return new t.Text(text.value, text.sourceSpan);
    };
    NonBindableVisitor.prototype.visitExpansion = function (expansion) {
        return null;
    };
    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase) {
        return null;
    };
    NonBindableVisitor.prototype.visitBlockGroup = function (group, context) {
        var nodes = html.visitAll(this, group.blocks);
        if (group.endSourceSpan !== null) {
            nodes.push(new t.Text(group.endSourceSpan.toString(), group.endSourceSpan));
        }
        return nodes;
    };
    NonBindableVisitor.prototype.visitBlock = function (block, context) {
        return __spreadArray([
            new t.Text(block.startSourceSpan.toString(), block.startSourceSpan)
        ], __read(html.visitAll(this, block.children)), false);
    };
    NonBindableVisitor.prototype.visitBlockParameter = function (parameter, context) {
        return null;
    };
    return NonBindableVisitor;
}());
var NON_BINDABLE_VISITOR = new NonBindableVisitor();
function normalizeAttributeName(attrName) {
    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
}
function addEvents(events, boundEvents) {
    boundEvents.push.apply(boundEvents, __spreadArray([], __read(events.map(function (e) { return t.BoundEvent.fromParsedEvent(e); })), false));
}
function isEmptyTextNode(node) {
    return node instanceof html.Text && node.value.trim().length == 0;
}
function isCommentNode(node) {
    return node instanceof html.Comment;
}
function textContents(node) {
    if (node.children.length !== 1 || !(node.children[0] instanceof html.Text)) {
        return null;
    }
    else {
        return node.children[0].value;
    }
}
