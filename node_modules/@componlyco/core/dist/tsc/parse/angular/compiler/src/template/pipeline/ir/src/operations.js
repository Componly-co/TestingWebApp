"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpList = void 0;
var enums_1 = require("./enums");
var OpList = exports.OpList = (function () {
    function OpList() {
        this.debugListId = OpList.nextListId++;
        this.head = {
            kind: enums_1.OpKind.ListEnd,
            next: null,
            prev: null,
            debugListId: this.debugListId,
        };
        this.tail = {
            kind: enums_1.OpKind.ListEnd,
            next: null,
            prev: null,
            debugListId: this.debugListId,
        };
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }
    OpList.prototype.push = function (op) {
        OpList.assertIsNotEnd(op);
        OpList.assertIsUnowned(op);
        op.debugListId = this.debugListId;
        var oldLast = this.tail.prev;
        op.prev = oldLast;
        oldLast.next = op;
        op.next = this.tail;
        this.tail.prev = op;
    };
    OpList.prototype.prepend = function (ops) {
        var e_1, _a, e_2, _b;
        if (ops.length === 0) {
            return;
        }
        try {
            for (var ops_1 = __values(ops), ops_1_1 = ops_1.next(); !ops_1_1.done; ops_1_1 = ops_1.next()) {
                var op = ops_1_1.value;
                OpList.assertIsNotEnd(op);
                OpList.assertIsUnowned(op);
                op.debugListId = this.debugListId;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ops_1_1 && !ops_1_1.done && (_a = ops_1.return)) _a.call(ops_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var first = this.head.next;
        var prev = this.head;
        try {
            for (var ops_2 = __values(ops), ops_2_1 = ops_2.next(); !ops_2_1.done; ops_2_1 = ops_2.next()) {
                var op = ops_2_1.value;
                prev.next = op;
                op.prev = prev;
                prev = op;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (ops_2_1 && !ops_2_1.done && (_b = ops_2.return)) _b.call(ops_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        prev.next = first;
        first.prev = prev;
    };
    OpList.prototype[Symbol.iterator] = function () {
        var current, next;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    current = this.head.next;
                    _a.label = 1;
                case 1:
                    if (!(current !== this.tail)) return [3, 3];
                    OpList.assertIsOwned(current, this.debugListId);
                    next = current.next;
                    return [4, current];
                case 2:
                    _a.sent();
                    current = next;
                    return [3, 1];
                case 3: return [2];
            }
        });
    };
    OpList.prototype.reversed = function () {
        var current, prev;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    current = this.tail.prev;
                    _a.label = 1;
                case 1:
                    if (!(current !== this.head)) return [3, 3];
                    OpList.assertIsOwned(current, this.debugListId);
                    prev = current.prev;
                    return [4, current];
                case 2:
                    _a.sent();
                    current = prev;
                    return [3, 1];
                case 3: return [2];
            }
        });
    };
    OpList.replace = function (oldOp, newOp) {
        OpList.assertIsNotEnd(oldOp);
        OpList.assertIsNotEnd(newOp);
        OpList.assertIsOwned(oldOp);
        OpList.assertIsUnowned(newOp);
        newOp.debugListId = oldOp.debugListId;
        if (oldOp.prev !== null) {
            oldOp.prev.next = newOp;
            newOp.prev = oldOp.prev;
        }
        if (oldOp.next !== null) {
            oldOp.next.prev = newOp;
            newOp.next = oldOp.next;
        }
        oldOp.debugListId = null;
        oldOp.prev = null;
        oldOp.next = null;
    };
    OpList.replaceWithMany = function (oldOp, newOps) {
        var e_3, _a, e_4, _b;
        if (newOps.length === 0) {
            OpList.remove(oldOp);
            return;
        }
        OpList.assertIsNotEnd(oldOp);
        OpList.assertIsOwned(oldOp);
        var listId = oldOp.debugListId;
        oldOp.debugListId = null;
        try {
            for (var newOps_1 = __values(newOps), newOps_1_1 = newOps_1.next(); !newOps_1_1.done; newOps_1_1 = newOps_1.next()) {
                var newOp = newOps_1_1.value;
                OpList.assertIsNotEnd(newOp);
                OpList.assertIsUnowned(newOp);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (newOps_1_1 && !newOps_1_1.done && (_a = newOps_1.return)) _a.call(newOps_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var oldPrev = oldOp.prev, oldNext = oldOp.next;
        oldOp.prev = null;
        oldOp.next = null;
        var prev = oldPrev;
        try {
            for (var newOps_2 = __values(newOps), newOps_2_1 = newOps_2.next(); !newOps_2_1.done; newOps_2_1 = newOps_2.next()) {
                var newOp = newOps_2_1.value;
                this.assertIsUnowned(newOp);
                newOp.debugListId = listId;
                prev.next = newOp;
                newOp.prev = prev;
                newOp.next = null;
                prev = newOp;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (newOps_2_1 && !newOps_2_1.done && (_b = newOps_2.return)) _b.call(newOps_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
        var first = newOps[0];
        var last = prev;
        if (oldPrev !== null) {
            oldPrev.next = first;
            first.prev = oldOp.prev;
        }
        if (oldNext !== null) {
            oldNext.prev = last;
            last.next = oldNext;
        }
    };
    OpList.remove = function (op) {
        OpList.assertIsNotEnd(op);
        OpList.assertIsOwned(op);
        op.prev.next = op.next;
        op.next.prev = op.prev;
        op.debugListId = null;
        op.prev = null;
        op.next = null;
    };
    OpList.insertBefore = function (op, target) {
        OpList.assertIsOwned(target);
        if (target.prev === null) {
            throw new Error("AssertionError: illegal operation on list start");
        }
        OpList.assertIsNotEnd(op);
        OpList.assertIsUnowned(op);
        op.debugListId = target.debugListId;
        op.prev = null;
        target.prev.next = op;
        op.prev = target.prev;
        op.next = target;
        target.prev = op;
    };
    OpList.insertAfter = function (op, target) {
        OpList.assertIsOwned(target);
        if (target.next === null) {
            throw new Error("AssertionError: illegal operation on list end");
        }
        OpList.assertIsNotEnd(op);
        OpList.assertIsUnowned(op);
        op.debugListId = target.debugListId;
        target.next.prev = op;
        op.next = target.next;
        op.prev = target;
        target.next = op;
    };
    OpList.assertIsUnowned = function (op) {
        if (op.debugListId !== null) {
            throw new Error("AssertionError: illegal operation on owned node: ".concat(enums_1.OpKind[op.kind]));
        }
    };
    OpList.assertIsOwned = function (op, byList) {
        if (op.debugListId === null) {
            throw new Error("AssertionError: illegal operation on unowned node: ".concat(enums_1.OpKind[op.kind]));
        }
        else if (byList !== undefined && op.debugListId !== byList) {
            throw new Error("AssertionError: node belongs to the wrong list (expected ".concat(byList, ", actual ").concat(op.debugListId, ")"));
        }
    };
    OpList.assertIsNotEnd = function (op) {
        if (op.kind === enums_1.OpKind.ListEnd) {
            throw new Error("AssertionError: illegal operation on list head or tail");
        }
    };
    OpList.nextListId = 0;
    return OpList;
}());
