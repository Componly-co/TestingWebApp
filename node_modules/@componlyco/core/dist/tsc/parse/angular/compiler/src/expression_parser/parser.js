"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._ParseAST = exports.Parser = exports.TemplateBindingParseResult = exports.SplitInterpolation = void 0;
var chars = __importStar(require("../chars"));
var interpolation_config_1 = require("../ml_parser/interpolation_config");
var ast_1 = require("./ast");
var lexer_1 = require("./lexer");
var SplitInterpolation = (function () {
    function SplitInterpolation(strings, expressions, offsets) {
        this.strings = strings;
        this.expressions = expressions;
        this.offsets = offsets;
    }
    return SplitInterpolation;
}());
exports.SplitInterpolation = SplitInterpolation;
var TemplateBindingParseResult = (function () {
    function TemplateBindingParseResult(templateBindings, warnings, errors) {
        this.templateBindings = templateBindings;
        this.warnings = warnings;
        this.errors = errors;
    }
    return TemplateBindingParseResult;
}());
exports.TemplateBindingParseResult = TemplateBindingParseResult;
var Parser = (function () {
    function Parser(_lexer) {
        this._lexer = _lexer;
        this.errors = [];
    }
    Parser.prototype.parseAction = function (input, isAssignmentEvent, location, absoluteOffset, interpolationConfig) {
        if (interpolationConfig === void 0) { interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG; }
        this._checkNoInterpolation(input, location, interpolationConfig);
        var sourceToLex = this._stripComments(input);
        var tokens = this._lexer.tokenize(sourceToLex);
        var flags = 1;
        if (isAssignmentEvent) {
            flags |= 2;
        }
        var ast = new _ParseAST(input, location, absoluteOffset, tokens, flags, this.errors, 0).parseChain();
        return new ast_1.ASTWithSource(ast, input, location, absoluteOffset, this.errors);
    };
    Parser.prototype.parseBinding = function (input, location, absoluteOffset, interpolationConfig) {
        if (interpolationConfig === void 0) { interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG; }
        var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
        return new ast_1.ASTWithSource(ast, input, location, absoluteOffset, this.errors);
    };
    Parser.prototype.checkSimpleExpression = function (ast) {
        var checker = new SimpleExpressionChecker();
        ast.visit(checker);
        return checker.errors;
    };
    Parser.prototype.parseSimpleBinding = function (input, location, absoluteOffset, interpolationConfig) {
        if (interpolationConfig === void 0) { interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG; }
        var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
        var errors = this.checkSimpleExpression(ast);
        if (errors.length > 0) {
            this._reportError("Host binding expression cannot contain ".concat(errors.join(' ')), input, location);
        }
        return new ast_1.ASTWithSource(ast, input, location, absoluteOffset, this.errors);
    };
    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {
        this.errors.push(new ast_1.ParserError(message, input, errLocation, ctxLocation));
    };
    Parser.prototype._parseBindingAst = function (input, location, absoluteOffset, interpolationConfig) {
        this._checkNoInterpolation(input, location, interpolationConfig);
        var sourceToLex = this._stripComments(input);
        var tokens = this._lexer.tokenize(sourceToLex);
        return new _ParseAST(input, location, absoluteOffset, tokens, 0, this.errors, 0)
            .parseChain();
    };
    Parser.prototype.parseTemplateBindings = function (templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
        var tokens = this._lexer.tokenize(templateValue);
        var parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, 0, this.errors, 0);
        return parser.parseTemplateBindings({
            source: templateKey,
            span: new ast_1.AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),
        });
    };
    Parser.prototype.parseInterpolation = function (input, location, absoluteOffset, interpolatedTokens, interpolationConfig) {
        if (interpolationConfig === void 0) { interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG; }
        var _a = this.splitInterpolation(input, location, interpolatedTokens, interpolationConfig), strings = _a.strings, expressions = _a.expressions, offsets = _a.offsets;
        if (expressions.length === 0)
            return null;
        var expressionNodes = [];
        for (var i = 0; i < expressions.length; ++i) {
            var expressionText = expressions[i].text;
            var sourceToLex = this._stripComments(expressionText);
            var tokens = this._lexer.tokenize(sourceToLex);
            var ast = new _ParseAST(input, location, absoluteOffset, tokens, 0, this.errors, offsets[i])
                .parseChain();
            expressionNodes.push(ast);
        }
        return this.createInterpolationAst(strings.map(function (s) { return s.text; }), expressionNodes, input, location, absoluteOffset);
    };
    Parser.prototype.parseInterpolationExpression = function (expression, location, absoluteOffset) {
        var sourceToLex = this._stripComments(expression);
        var tokens = this._lexer.tokenize(sourceToLex);
        var ast = new _ParseAST(expression, location, absoluteOffset, tokens, 0, this.errors, 0)
            .parseChain();
        var strings = ['', ''];
        return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);
    };
    Parser.prototype.createInterpolationAst = function (strings, expressions, input, location, absoluteOffset) {
        var span = new ast_1.ParseSpan(0, input.length);
        var interpolation = new ast_1.Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);
        return new ast_1.ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);
    };
    Parser.prototype.splitInterpolation = function (input, location, interpolatedTokens, interpolationConfig) {
        var _a;
        if (interpolationConfig === void 0) { interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG; }
        var strings = [];
        var expressions = [];
        var offsets = [];
        var inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;
        var i = 0;
        var atInterpolation = false;
        var extendLastString = false;
        var interpStart = interpolationConfig.start, interpEnd = interpolationConfig.end;
        while (i < input.length) {
            if (!atInterpolation) {
                var start = i;
                i = input.indexOf(interpStart, i);
                if (i === -1) {
                    i = input.length;
                }
                var text = input.substring(start, i);
                strings.push({ text: text, start: start, end: i });
                atInterpolation = true;
            }
            else {
                var fullStart = i;
                var exprStart = fullStart + interpStart.length;
                var exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);
                if (exprEnd === -1) {
                    atInterpolation = false;
                    extendLastString = true;
                    break;
                }
                var fullEnd = exprEnd + interpEnd.length;
                var text = input.substring(exprStart, exprEnd);
                if (text.trim().length === 0) {
                    this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column ".concat(i, " in"), location);
                }
                expressions.push({ text: text, start: fullStart, end: fullEnd });
                var startInOriginalTemplate = (_a = inputToTemplateIndexMap === null || inputToTemplateIndexMap === void 0 ? void 0 : inputToTemplateIndexMap.get(fullStart)) !== null && _a !== void 0 ? _a : fullStart;
                var offset = startInOriginalTemplate + interpStart.length;
                offsets.push(offset);
                i = fullEnd;
                atInterpolation = false;
            }
        }
        if (!atInterpolation) {
            if (extendLastString) {
                var piece = strings[strings.length - 1];
                piece.text += input.substring(i);
                piece.end = input.length;
            }
            else {
                strings.push({ text: input.substring(i), start: i, end: input.length });
            }
        }
        return new SplitInterpolation(strings, expressions, offsets);
    };
    Parser.prototype.wrapLiteralPrimitive = function (input, location, absoluteOffset) {
        var span = new ast_1.ParseSpan(0, input == null ? 0 : input.length);
        return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);
    };
    Parser.prototype._stripComments = function (input) {
        var i = this._commentStart(input);
        return i != null ? input.substring(0, i) : input;
    };
    Parser.prototype._commentStart = function (input) {
        var outerQuote = null;
        for (var i = 0; i < input.length - 1; i++) {
            var char = input.charCodeAt(i);
            var nextChar = input.charCodeAt(i + 1);
            if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null)
                return i;
            if (outerQuote === char) {
                outerQuote = null;
            }
            else if (outerQuote == null && chars.isQuote(char)) {
                outerQuote = char;
            }
        }
        return null;
    };
    Parser.prototype._checkNoInterpolation = function (input, location, _a) {
        var e_1, _b;
        var start = _a.start, end = _a.end;
        var startIndex = -1;
        var endIndex = -1;
        try {
            for (var _c = __values(this._forEachUnquotedChar(input, 0)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var charIndex = _d.value;
                if (startIndex === -1) {
                    if (input.startsWith(start)) {
                        startIndex = charIndex;
                    }
                }
                else {
                    endIndex = this._getInterpolationEndIndex(input, end, charIndex);
                    if (endIndex > -1) {
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (startIndex > -1 && endIndex > -1) {
            this._reportError("Got interpolation (".concat(start).concat(end, ") where expression was expected"), input, "at column ".concat(startIndex, " in"), location);
        }
    };
    Parser.prototype._getInterpolationEndIndex = function (input, expressionEnd, start) {
        var e_2, _a;
        try {
            for (var _b = __values(this._forEachUnquotedChar(input, start)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var charIndex = _c.value;
                if (input.startsWith(expressionEnd, charIndex)) {
                    return charIndex;
                }
                if (input.startsWith('//', charIndex)) {
                    return input.indexOf(expressionEnd, charIndex);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return -1;
    };
    Parser.prototype._forEachUnquotedChar = function (input, start) {
        var currentQuote, escapeCount, i, char;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    currentQuote = null;
                    escapeCount = 0;
                    i = start;
                    _a.label = 1;
                case 1:
                    if (!(i < input.length)) return [3, 6];
                    char = input[i];
                    if (!(chars.isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&
                        escapeCount % 2 === 0)) return [3, 2];
                    currentQuote = currentQuote === null ? char : null;
                    return [3, 4];
                case 2:
                    if (!(currentQuote === null)) return [3, 4];
                    return [4, i];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4:
                    escapeCount = char === '\\' ? escapeCount + 1 : 0;
                    _a.label = 5;
                case 5:
                    i++;
                    return [3, 1];
                case 6: return [2];
            }
        });
    };
    return Parser;
}());
exports.Parser = Parser;
var ParseContextFlags;
(function (ParseContextFlags) {
    ParseContextFlags[ParseContextFlags["None"] = 0] = "None";
    ParseContextFlags[ParseContextFlags["Writable"] = 1] = "Writable";
})(ParseContextFlags || (ParseContextFlags = {}));
var _ParseAST = (function () {
    function _ParseAST(input, location, absoluteOffset, tokens, parseFlags, errors, offset) {
        this.input = input;
        this.location = location;
        this.absoluteOffset = absoluteOffset;
        this.tokens = tokens;
        this.parseFlags = parseFlags;
        this.errors = errors;
        this.offset = offset;
        this.rparensExpected = 0;
        this.rbracketsExpected = 0;
        this.rbracesExpected = 0;
        this.context = ParseContextFlags.None;
        this.sourceSpanCache = new Map();
        this.index = 0;
    }
    _ParseAST.prototype.peek = function (offset) {
        var i = this.index + offset;
        return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;
    };
    Object.defineProperty(_ParseAST.prototype, "next", {
        get: function () {
            return this.peek(0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "atEOF", {
        get: function () {
            return this.index >= this.tokens.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
        get: function () {
            return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "currentEndIndex", {
        get: function () {
            if (this.index > 0) {
                var curToken = this.peek(-1);
                return curToken.end + this.offset;
            }
            if (this.tokens.length === 0) {
                return this.input.length + this.offset;
            }
            return this.next.index + this.offset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_ParseAST.prototype, "currentAbsoluteOffset", {
        get: function () {
            return this.absoluteOffset + this.inputIndex;
        },
        enumerable: false,
        configurable: true
    });
    _ParseAST.prototype.span = function (start, artificialEndIndex) {
        var endIndex = this.currentEndIndex;
        if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {
            endIndex = artificialEndIndex;
        }
        if (start > endIndex) {
            var tmp = endIndex;
            endIndex = start;
            start = tmp;
        }
        return new ast_1.ParseSpan(start, endIndex);
    };
    _ParseAST.prototype.sourceSpan = function (start, artificialEndIndex) {
        var serial = "".concat(start, "@").concat(this.inputIndex, ":").concat(artificialEndIndex);
        if (!this.sourceSpanCache.has(serial)) {
            this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));
        }
        return this.sourceSpanCache.get(serial);
    };
    _ParseAST.prototype.advance = function () {
        this.index++;
    };
    _ParseAST.prototype.withContext = function (context, cb) {
        this.context |= context;
        var ret = cb();
        this.context ^= context;
        return ret;
    };
    _ParseAST.prototype.consumeOptionalCharacter = function (code) {
        if (this.next.isCharacter(code)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.peekKeywordLet = function () {
        return this.next.isKeywordLet();
    };
    _ParseAST.prototype.peekKeywordAs = function () {
        return this.next.isKeywordAs();
    };
    _ParseAST.prototype.expectCharacter = function (code) {
        if (this.consumeOptionalCharacter(code))
            return;
        this.error("Missing expected ".concat(String.fromCharCode(code)));
    };
    _ParseAST.prototype.consumeOptionalOperator = function (op) {
        if (this.next.isOperator(op)) {
            this.advance();
            return true;
        }
        else {
            return false;
        }
    };
    _ParseAST.prototype.expectOperator = function (operator) {
        if (this.consumeOptionalOperator(operator))
            return;
        this.error("Missing expected operator ".concat(operator));
    };
    _ParseAST.prototype.prettyPrintToken = function (tok) {
        return tok === lexer_1.EOF ? 'end of input' : "token ".concat(tok);
    };
    _ParseAST.prototype.expectIdentifierOrKeyword = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword()) {
            if (n.isPrivateIdentifier()) {
                this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');
            }
            else {
                this.error("Unexpected ".concat(this.prettyPrintToken(n), ", expected identifier or keyword"));
            }
            return null;
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
        var n = this.next;
        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
            if (n.isPrivateIdentifier()) {
                this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');
            }
            else {
                this.error("Unexpected ".concat(this.prettyPrintToken(n), ", expected identifier, keyword, or string"));
            }
            return '';
        }
        this.advance();
        return n.toString();
    };
    _ParseAST.prototype.parseChain = function () {
        var exprs = [];
        var start = this.inputIndex;
        while (this.index < this.tokens.length) {
            var expr = this.parsePipe();
            exprs.push(expr);
            if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {
                if (!(this.parseFlags & 1)) {
                    this.error('Binding expression cannot contain chained expression');
                }
                while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {
                }
            }
            else if (this.index < this.tokens.length) {
                var errorIndex = this.index;
                this.error("Unexpected token '".concat(this.next, "'"));
                if (this.index === errorIndex) {
                    break;
                }
            }
        }
        if (exprs.length === 0) {
            var artificialStart = this.offset;
            var artificialEnd = this.offset + this.input.length;
            return new ast_1.EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));
        }
        if (exprs.length == 1)
            return exprs[0];
        return new ast_1.Chain(this.span(start), this.sourceSpan(start), exprs);
    };
    _ParseAST.prototype.parsePipe = function () {
        var start = this.inputIndex;
        var result = this.parseExpression();
        if (this.consumeOptionalOperator('|')) {
            if (this.parseFlags & 1) {
                this.error('Cannot have a pipe in an action expression');
            }
            do {
                var nameStart = this.inputIndex;
                var nameId = this.expectIdentifierOrKeyword();
                var nameSpan = void 0;
                var fullSpanEnd = undefined;
                if (nameId !== null) {
                    nameSpan = this.sourceSpan(nameStart);
                }
                else {
                    nameId = '';
                    fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;
                    nameSpan = new ast_1.ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);
                }
                var args = [];
                while (this.consumeOptionalCharacter(chars.$COLON)) {
                    args.push(this.parseExpression());
                }
                result = new ast_1.BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);
            } while (this.consumeOptionalOperator('|'));
        }
        return result;
    };
    _ParseAST.prototype.parseExpression = function () {
        return this.parseConditional();
    };
    _ParseAST.prototype.parseConditional = function () {
        var start = this.inputIndex;
        var result = this.parseLogicalOr();
        if (this.consumeOptionalOperator('?')) {
            var yes = this.parsePipe();
            var no = void 0;
            if (!this.consumeOptionalCharacter(chars.$COLON)) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error("Conditional expression ".concat(expression, " requires all 3 expressions"));
                no = new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            else {
                no = this.parsePipe();
            }
            return new ast_1.Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
        }
        else {
            return result;
        }
    };
    _ParseAST.prototype.parseLogicalOr = function () {
        var start = this.inputIndex;
        var result = this.parseLogicalAnd();
        while (this.consumeOptionalOperator('||')) {
            var right = this.parseLogicalAnd();
            result = new ast_1.Binary(this.span(start), this.sourceSpan(start), '||', result, right);
        }
        return result;
    };
    _ParseAST.prototype.parseLogicalAnd = function () {
        var start = this.inputIndex;
        var result = this.parseNullishCoalescing();
        while (this.consumeOptionalOperator('&&')) {
            var right = this.parseNullishCoalescing();
            result = new ast_1.Binary(this.span(start), this.sourceSpan(start), '&&', result, right);
        }
        return result;
    };
    _ParseAST.prototype.parseNullishCoalescing = function () {
        var start = this.inputIndex;
        var result = this.parseEquality();
        while (this.consumeOptionalOperator('??')) {
            var right = this.parseEquality();
            result = new ast_1.Binary(this.span(start), this.sourceSpan(start), '??', result, right);
        }
        return result;
    };
    _ParseAST.prototype.parseEquality = function () {
        var start = this.inputIndex;
        var result = this.parseRelational();
        while (this.next.type == lexer_1.TokenType.Operator) {
            var operator = this.next.strValue;
            switch (operator) {
                case '==':
                case '===':
                case '!=':
                case '!==':
                    this.advance();
                    var right = this.parseRelational();
                    result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                    continue;
            }
            break;
        }
        return result;
    };
    _ParseAST.prototype.parseRelational = function () {
        var start = this.inputIndex;
        var result = this.parseAdditive();
        while (this.next.type == lexer_1.TokenType.Operator) {
            var operator = this.next.strValue;
            switch (operator) {
                case '<':
                case '>':
                case '<=':
                case '>=':
                    this.advance();
                    var right = this.parseAdditive();
                    result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                    continue;
            }
            break;
        }
        return result;
    };
    _ParseAST.prototype.parseAdditive = function () {
        var start = this.inputIndex;
        var result = this.parseMultiplicative();
        while (this.next.type == lexer_1.TokenType.Operator) {
            var operator = this.next.strValue;
            switch (operator) {
                case '+':
                case '-':
                    this.advance();
                    var right = this.parseMultiplicative();
                    result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                    continue;
            }
            break;
        }
        return result;
    };
    _ParseAST.prototype.parseMultiplicative = function () {
        var start = this.inputIndex;
        var result = this.parsePrefix();
        while (this.next.type == lexer_1.TokenType.Operator) {
            var operator = this.next.strValue;
            switch (operator) {
                case '*':
                case '%':
                case '/':
                    this.advance();
                    var right = this.parsePrefix();
                    result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                    continue;
            }
            break;
        }
        return result;
    };
    _ParseAST.prototype.parsePrefix = function () {
        if (this.next.type == lexer_1.TokenType.Operator) {
            var start = this.inputIndex;
            var operator = this.next.strValue;
            var result = void 0;
            switch (operator) {
                case '+':
                    this.advance();
                    result = this.parsePrefix();
                    return ast_1.Unary.createPlus(this.span(start), this.sourceSpan(start), result);
                case '-':
                    this.advance();
                    result = this.parsePrefix();
                    return ast_1.Unary.createMinus(this.span(start), this.sourceSpan(start), result);
                case '!':
                    this.advance();
                    result = this.parsePrefix();
                    return new ast_1.PrefixNot(this.span(start), this.sourceSpan(start), result);
            }
        }
        return this.parseCallChain();
    };
    _ParseAST.prototype.parseCallChain = function () {
        var start = this.inputIndex;
        var result = this.parsePrimary();
        while (true) {
            if (this.consumeOptionalCharacter(chars.$PERIOD)) {
                result = this.parseAccessMember(result, start, false);
            }
            else if (this.consumeOptionalOperator('?.')) {
                if (this.consumeOptionalCharacter(chars.$LPAREN)) {
                    result = this.parseCall(result, start, true);
                }
                else {
                    result = this.consumeOptionalCharacter(chars.$LBRACKET) ?
                        this.parseKeyedReadOrWrite(result, start, true) :
                        this.parseAccessMember(result, start, true);
                }
            }
            else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {
                result = this.parseKeyedReadOrWrite(result, start, false);
            }
            else if (this.consumeOptionalCharacter(chars.$LPAREN)) {
                result = this.parseCall(result, start, false);
            }
            else if (this.consumeOptionalOperator('!')) {
                result = new ast_1.NonNullAssert(this.span(start), this.sourceSpan(start), result);
            }
            else {
                return result;
            }
        }
    };
    _ParseAST.prototype.parsePrimary = function () {
        var start = this.inputIndex;
        if (this.consumeOptionalCharacter(chars.$LPAREN)) {
            this.rparensExpected++;
            var result = this.parsePipe();
            this.rparensExpected--;
            this.expectCharacter(chars.$RPAREN);
            return result;
        }
        else if (this.next.isKeywordNull()) {
            this.advance();
            return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
        }
        else if (this.next.isKeywordUndefined()) {
            this.advance();
            return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
        }
        else if (this.next.isKeywordTrue()) {
            this.advance();
            return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
        }
        else if (this.next.isKeywordFalse()) {
            this.advance();
            return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
        }
        else if (this.next.isKeywordThis()) {
            this.advance();
            return new ast_1.ThisReceiver(this.span(start), this.sourceSpan(start));
        }
        else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {
            this.rbracketsExpected++;
            var elements = this.parseExpressionList(chars.$RBRACKET);
            this.rbracketsExpected--;
            this.expectCharacter(chars.$RBRACKET);
            return new ast_1.LiteralArray(this.span(start), this.sourceSpan(start), elements);
        }
        else if (this.next.isCharacter(chars.$LBRACE)) {
            return this.parseLiteralMap();
        }
        else if (this.next.isIdentifier()) {
            return this.parseAccessMember(new ast_1.ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);
        }
        else if (this.next.isNumber()) {
            var value = this.next.toNumber();
            this.advance();
            return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
        }
        else if (this.next.isString()) {
            var literalValue = this.next.toString();
            this.advance();
            return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
        }
        else if (this.next.isPrivateIdentifier()) {
            this._reportErrorForPrivateIdentifier(this.next, null);
            return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));
        }
        else if (this.index >= this.tokens.length) {
            this.error("Unexpected end of expression: ".concat(this.input));
            return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));
        }
        else {
            this.error("Unexpected token ".concat(this.next));
            return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));
        }
    };
    _ParseAST.prototype.parseExpressionList = function (terminator) {
        var result = [];
        do {
            if (!this.next.isCharacter(terminator)) {
                result.push(this.parsePipe());
            }
            else {
                break;
            }
        } while (this.consumeOptionalCharacter(chars.$COMMA));
        return result;
    };
    _ParseAST.prototype.parseLiteralMap = function () {
        var keys = [];
        var values = [];
        var start = this.inputIndex;
        this.expectCharacter(chars.$LBRACE);
        if (!this.consumeOptionalCharacter(chars.$RBRACE)) {
            this.rbracesExpected++;
            do {
                var keyStart = this.inputIndex;
                var quoted = this.next.isString();
                var key = this.expectIdentifierOrKeywordOrString();
                keys.push({ key: key, quoted: quoted });
                if (quoted) {
                    this.expectCharacter(chars.$COLON);
                    values.push(this.parsePipe());
                }
                else if (this.consumeOptionalCharacter(chars.$COLON)) {
                    values.push(this.parsePipe());
                }
                else {
                    var span = this.span(keyStart);
                    var sourceSpan = this.sourceSpan(keyStart);
                    values.push(new ast_1.PropertyRead(span, sourceSpan, sourceSpan, new ast_1.ImplicitReceiver(span, sourceSpan), key));
                }
            } while (this.consumeOptionalCharacter(chars.$COMMA) &&
                !this.next.isCharacter(chars.$RBRACE));
            this.rbracesExpected--;
            this.expectCharacter(chars.$RBRACE);
        }
        return new ast_1.LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
    };
    _ParseAST.prototype.parseAccessMember = function (readReceiver, start, isSafe) {
        var _this = this;
        var nameStart = this.inputIndex;
        var id = this.withContext(ParseContextFlags.Writable, function () {
            var _a;
            var id = (_a = _this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';
            if (id.length === 0) {
                _this.error("Expected identifier for property access", readReceiver.span.end);
            }
            return id;
        });
        var nameSpan = this.sourceSpan(nameStart);
        var receiver;
        if (isSafe) {
            if (this.consumeOptionalAssignment()) {
                this.error('The \'?.\' operator cannot be used in the assignment');
                receiver = new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            else {
                receiver = new ast_1.SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
            }
        }
        else {
            if (this.consumeOptionalAssignment()) {
                if (!(this.parseFlags & 1)) {
                    this.error('Bindings cannot contain assignments');
                    return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));
                }
                var value = this.parseConditional();
                receiver = new ast_1.PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);
            }
            else {
                receiver =
                    new ast_1.PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
            }
        }
        return receiver;
    };
    _ParseAST.prototype.parseCall = function (receiver, start, isSafe) {
        var argumentStart = this.inputIndex;
        this.rparensExpected++;
        var args = this.parseCallArguments();
        var argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
        this.expectCharacter(chars.$RPAREN);
        this.rparensExpected--;
        var span = this.span(start);
        var sourceSpan = this.sourceSpan(start);
        return isSafe ? new ast_1.SafeCall(span, sourceSpan, receiver, args, argumentSpan) :
            new ast_1.Call(span, sourceSpan, receiver, args, argumentSpan);
    };
    _ParseAST.prototype.consumeOptionalAssignment = function () {
        if ((this.parseFlags & 2) && this.next.isOperator('!') &&
            this.peek(1).isOperator('=')) {
            this.advance();
            this.advance();
            return true;
        }
        return this.consumeOptionalOperator('=');
    };
    _ParseAST.prototype.parseCallArguments = function () {
        if (this.next.isCharacter(chars.$RPAREN))
            return [];
        var positionals = [];
        do {
            positionals.push(this.parsePipe());
        } while (this.consumeOptionalCharacter(chars.$COMMA));
        return positionals;
    };
    _ParseAST.prototype.expectTemplateBindingKey = function () {
        var result = '';
        var operatorFound = false;
        var start = this.currentAbsoluteOffset;
        do {
            result += this.expectIdentifierOrKeywordOrString();
            operatorFound = this.consumeOptionalOperator('-');
            if (operatorFound) {
                result += '-';
            }
        } while (operatorFound);
        return {
            source: result,
            span: new ast_1.AbsoluteSourceSpan(start, start + result.length),
        };
    };
    _ParseAST.prototype.parseTemplateBindings = function (templateKey) {
        var bindings = [];
        bindings.push.apply(bindings, __spreadArray([], __read(this.parseDirectiveKeywordBindings(templateKey)), false));
        while (this.index < this.tokens.length) {
            var letBinding = this.parseLetBinding();
            if (letBinding) {
                bindings.push(letBinding);
            }
            else {
                var key = this.expectTemplateBindingKey();
                var binding = this.parseAsBinding(key);
                if (binding) {
                    bindings.push(binding);
                }
                else {
                    key.source =
                        templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);
                    bindings.push.apply(bindings, __spreadArray([], __read(this.parseDirectiveKeywordBindings(key)), false));
                }
            }
            this.consumeStatementTerminator();
        }
        return new TemplateBindingParseResult(bindings, [], this.errors);
    };
    _ParseAST.prototype.parseKeyedReadOrWrite = function (receiver, start, isSafe) {
        var _this = this;
        return this.withContext(ParseContextFlags.Writable, function () {
            _this.rbracketsExpected++;
            var key = _this.parsePipe();
            if (key instanceof ast_1.EmptyExpr) {
                _this.error("Key access cannot be empty");
            }
            _this.rbracketsExpected--;
            _this.expectCharacter(chars.$RBRACKET);
            if (_this.consumeOptionalOperator('=')) {
                if (isSafe) {
                    _this.error('The \'?.\' operator cannot be used in the assignment');
                }
                else {
                    var value = _this.parseConditional();
                    return new ast_1.KeyedWrite(_this.span(start), _this.sourceSpan(start), receiver, key, value);
                }
            }
            else {
                return isSafe ? new ast_1.SafeKeyedRead(_this.span(start), _this.sourceSpan(start), receiver, key) :
                    new ast_1.KeyedRead(_this.span(start), _this.sourceSpan(start), receiver, key);
            }
            return new ast_1.EmptyExpr(_this.span(start), _this.sourceSpan(start));
        });
    };
    _ParseAST.prototype.parseDirectiveKeywordBindings = function (key) {
        var bindings = [];
        this.consumeOptionalCharacter(chars.$COLON);
        var value = this.getDirectiveBoundTarget();
        var spanEnd = this.currentAbsoluteOffset;
        var asBinding = this.parseAsBinding(key);
        if (!asBinding) {
            this.consumeStatementTerminator();
            spanEnd = this.currentAbsoluteOffset;
        }
        var sourceSpan = new ast_1.AbsoluteSourceSpan(key.span.start, spanEnd);
        bindings.push(new ast_1.ExpressionBinding(sourceSpan, key, value));
        if (asBinding) {
            bindings.push(asBinding);
        }
        return bindings;
    };
    _ParseAST.prototype.getDirectiveBoundTarget = function () {
        if (this.next === lexer_1.EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
            return null;
        }
        var ast = this.parsePipe();
        var _a = ast.span, start = _a.start, end = _a.end;
        var value = this.input.substring(start, end);
        return new ast_1.ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
    };
    _ParseAST.prototype.parseAsBinding = function (value) {
        if (!this.peekKeywordAs()) {
            return null;
        }
        this.advance();
        var key = this.expectTemplateBindingKey();
        this.consumeStatementTerminator();
        var sourceSpan = new ast_1.AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
        return new ast_1.VariableBinding(sourceSpan, key, value);
    };
    _ParseAST.prototype.parseLetBinding = function () {
        if (!this.peekKeywordLet()) {
            return null;
        }
        var spanStart = this.currentAbsoluteOffset;
        this.advance();
        var key = this.expectTemplateBindingKey();
        var value = null;
        if (this.consumeOptionalOperator('=')) {
            value = this.expectTemplateBindingKey();
        }
        this.consumeStatementTerminator();
        var sourceSpan = new ast_1.AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
        return new ast_1.VariableBinding(sourceSpan, key, value);
    };
    _ParseAST.prototype.consumeStatementTerminator = function () {
        this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);
    };
    _ParseAST.prototype.error = function (message, index) {
        if (index === void 0) { index = null; }
        this.errors.push(new ast_1.ParserError(message, this.input, this.locationText(index), this.location));
        this.skip();
    };
    _ParseAST.prototype.locationText = function (index) {
        if (index === void 0) { index = null; }
        if (index == null)
            index = this.index;
        return (index < this.tokens.length) ? "at column ".concat(this.tokens[index].index + 1, " in") :
            "at the end of the expression";
    };
    _ParseAST.prototype._reportErrorForPrivateIdentifier = function (token, extraMessage) {
        var errorMessage = "Private identifiers are not supported. Unexpected private identifier: ".concat(token);
        if (extraMessage !== null) {
            errorMessage += ", ".concat(extraMessage);
        }
        this.error(errorMessage);
    };
    _ParseAST.prototype.skip = function () {
        var n = this.next;
        while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&
            !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&
            (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&
            (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&
            (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {
            if (this.next.isError()) {
                this.errors.push(new ast_1.ParserError(this.next.toString(), this.input, this.locationText(), this.location));
            }
            this.advance();
            n = this.next;
        }
    };
    return _ParseAST;
}());
exports._ParseAST = _ParseAST;
var SimpleExpressionChecker = (function (_super) {
    __extends(SimpleExpressionChecker, _super);
    function SimpleExpressionChecker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.errors = [];
        return _this;
    }
    SimpleExpressionChecker.prototype.visitPipe = function () {
        this.errors.push('pipes');
    };
    return SimpleExpressionChecker;
}(ast_1.RecursiveAstVisitor));
function getIndexMapForOriginalTemplate(interpolatedTokens) {
    var offsetMap = new Map();
    var consumedInOriginalTemplate = 0;
    var consumedInInput = 0;
    var tokenIndex = 0;
    while (tokenIndex < interpolatedTokens.length) {
        var currentToken = interpolatedTokens[tokenIndex];
        if (currentToken.type === 9) {
            var _a = __read(currentToken.parts, 2), decoded = _a[0], encoded = _a[1];
            consumedInOriginalTemplate += encoded.length;
            consumedInInput += decoded.length;
        }
        else {
            var lengthOfParts = currentToken.parts.reduce(function (sum, current) { return sum + current.length; }, 0);
            consumedInInput += lengthOfParts;
            consumedInOriginalTemplate += lengthOfParts;
        }
        offsetMap.set(consumedInInput, consumedInOriginalTemplate);
        tokenIndex++;
    }
    return offsetMap;
}
