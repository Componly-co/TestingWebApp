"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CursorError = exports.tokenize = exports.TokenizeResult = exports.TokenError = void 0;
var chars = __importStar(require("../chars"));
var parse_util_1 = require("../parse_util");
var entities_1 = require("./entities");
var interpolation_config_1 = require("./interpolation_config");
var tags_1 = require("./tags");
var TokenError = (function (_super) {
    __extends(TokenError, _super);
    function TokenError(errorMsg, tokenType, span) {
        var _this = _super.call(this, span, errorMsg) || this;
        _this.tokenType = tokenType;
        return _this;
    }
    return TokenError;
}(parse_util_1.ParseError));
exports.TokenError = TokenError;
var TokenizeResult = (function () {
    function TokenizeResult(tokens, errors, nonNormalizedIcuExpressions) {
        this.tokens = tokens;
        this.errors = errors;
        this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
    }
    return TokenizeResult;
}());
exports.TokenizeResult = TokenizeResult;
function tokenize(source, url, getTagDefinition, options) {
    if (options === void 0) { options = {}; }
    var tokenizer = new _Tokenizer(new parse_util_1.ParseSourceFile(source, url), getTagDefinition, options);
    tokenizer.tokenize();
    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
}
exports.tokenize = tokenize;
var _CR_OR_CRLF_REGEXP = /\r\n?/g;
function _unexpectedCharacterErrorMsg(charCode) {
    var char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);
    return "Unexpected character \"".concat(char, "\"");
}
function _unknownEntityErrorMsg(entitySrc) {
    return "Unknown entity \"".concat(entitySrc, "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax");
}
function _unparsableEntityErrorMsg(type, entityStr) {
    return "Unable to parse entity \"".concat(entityStr, "\" - ").concat(type, " character reference entities must end with \";\"");
}
var CharacterReferenceType;
(function (CharacterReferenceType) {
    CharacterReferenceType["HEX"] = "hexadecimal";
    CharacterReferenceType["DEC"] = "decimal";
})(CharacterReferenceType || (CharacterReferenceType = {}));
var _ControlFlowError = (function () {
    function _ControlFlowError(error) {
        this.error = error;
    }
    return _ControlFlowError;
}());
var _Tokenizer = (function () {
    function _Tokenizer(_file, _getTagDefinition, options) {
        this._getTagDefinition = _getTagDefinition;
        this._currentTokenStart = null;
        this._currentTokenType = null;
        this._expansionCaseStack = [];
        this._inInterpolation = false;
        this.tokens = [];
        this.errors = [];
        this.nonNormalizedIcuExpressions = [];
        this._tokenizeIcu = options.tokenizeExpansionForms || false;
        this._interpolationConfig = options.interpolationConfig || interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;
        this._leadingTriviaCodePoints =
            options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) { return c.codePointAt(0) || 0; });
        var range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };
        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :
            new PlainCharacterCursor(_file, range);
        this._preserveLineEndings = options.preserveLineEndings || false;
        this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
        this._tokenizeBlocks = options.tokenizeBlocks || false;
        try {
            this._cursor.init();
        }
        catch (e) {
            this.handleError(e);
        }
    }
    _Tokenizer.prototype._processCarriageReturns = function (content) {
        if (this._preserveLineEndings) {
            return content;
        }
        return content.replace(_CR_OR_CRLF_REGEXP, '\n');
    };
    _Tokenizer.prototype.tokenize = function () {
        var _this = this;
        while (this._cursor.peek() !== chars.$EOF) {
            var start = this._cursor.clone();
            try {
                if (this._attemptCharCode(chars.$LT)) {
                    if (this._attemptCharCode(chars.$BANG)) {
                        if (this._attemptCharCode(chars.$LBRACKET)) {
                            this._consumeCdata(start);
                        }
                        else if (this._attemptCharCode(chars.$MINUS)) {
                            this._consumeComment(start);
                        }
                        else {
                            this._consumeDocType(start);
                        }
                    }
                    else if (this._attemptCharCode(chars.$SLASH)) {
                        this._consumeTagClose(start);
                    }
                    else {
                        this._consumeTagOpen(start);
                    }
                }
                else if (this._tokenizeBlocks && this._attemptStr('{#')) {
                    this._consumeBlockGroupOpen(start);
                }
                else if (this._tokenizeBlocks && this._attemptStr('{/')) {
                    this._consumeBlockGroupClose(start);
                }
                else if (this._tokenizeBlocks && this._attemptStr('{:')) {
                    this._consumeBlock(start);
                }
                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
                    this._consumeWithInterpolation(5, 8, function () { return _this._isTextEnd(); }, function () { return _this._isTagStart(); });
                }
            }
            catch (e) {
                this.handleError(e);
            }
        }
        this._beginToken(24);
        this._endToken([]);
    };
    _Tokenizer.prototype._consumeBlockGroupOpen = function (start) {
        this._beginToken(25, start);
        var nameCursor = this._cursor.clone();
        this._attemptCharCodeUntilFn(function (code) { return !isBlockNameChar(code); });
        this._endToken([this._cursor.getChars(nameCursor)]);
        this._consumeBlockParameters();
        this._beginToken(26);
        this._requireCharCode(chars.$RBRACE);
        this._endToken([]);
    };
    _Tokenizer.prototype._consumeBlockGroupClose = function (start) {
        this._beginToken(27, start);
        var nameCursor = this._cursor.clone();
        this._attemptCharCodeUntilFn(function (code) { return !isBlockNameChar(code); });
        var name = this._cursor.getChars(nameCursor);
        this._requireCharCode(chars.$RBRACE);
        this._endToken([name]);
    };
    _Tokenizer.prototype._consumeBlock = function (start) {
        this._beginToken(29, start);
        var nameCursor = this._cursor.clone();
        this._attemptCharCodeUntilFn(function (code) { return !isBlockNameChar(code); });
        this._endToken([this._cursor.getChars(nameCursor)]);
        this._consumeBlockParameters();
        this._beginToken(30);
        this._requireCharCode(chars.$RBRACE);
        this._endToken([]);
    };
    _Tokenizer.prototype._consumeBlockParameters = function () {
        this._attemptCharCodeUntilFn(isBlockParameterChar);
        while (this._cursor.peek() !== chars.$RBRACE && this._cursor.peek() !== chars.$EOF) {
            this._beginToken(28);
            var start = this._cursor.clone();
            var inQuote = null;
            var openBraces = 0;
            while ((this._cursor.peek() !== chars.$SEMICOLON && this._cursor.peek() !== chars.$EOF) ||
                inQuote !== null) {
                var char = this._cursor.peek();
                if (char === chars.$BACKSLASH) {
                    this._cursor.advance();
                }
                else if (char === inQuote) {
                    inQuote = null;
                }
                else if (inQuote === null && chars.isQuote(char)) {
                    inQuote = char;
                }
                else if (char === chars.$LBRACE && inQuote === null) {
                    openBraces++;
                }
                else if (char === chars.$RBRACE && inQuote === null) {
                    if (openBraces === 0) {
                        break;
                    }
                    else if (openBraces > 0) {
                        openBraces--;
                    }
                }
                this._cursor.advance();
            }
            this._endToken([this._cursor.getChars(start)]);
            this._attemptCharCodeUntilFn(isBlockParameterChar);
        }
    };
    _Tokenizer.prototype._tokenizeExpansionForm = function () {
        if (this.isExpansionFormStart()) {
            this._consumeExpansionFormStart();
            return true;
        }
        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
            this._consumeExpansionCaseStart();
            return true;
        }
        if (this._cursor.peek() === chars.$RBRACE) {
            if (this._isInExpansionCase()) {
                this._consumeExpansionCaseEnd();
                return true;
            }
            if (this._isInExpansionForm()) {
                this._consumeExpansionFormEnd();
                return true;
            }
        }
        return false;
    };
    _Tokenizer.prototype._beginToken = function (type, start) {
        if (start === void 0) { start = this._cursor.clone(); }
        this._currentTokenStart = start;
        this._currentTokenType = type;
    };
    _Tokenizer.prototype._endToken = function (parts, end) {
        if (this._currentTokenStart === null) {
            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));
        }
        if (this._currentTokenType === null) {
            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
        }
        var token = {
            type: this._currentTokenType,
            parts: parts,
            sourceSpan: (end !== null && end !== void 0 ? end : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),
        };
        this.tokens.push(token);
        this._currentTokenStart = null;
        this._currentTokenType = null;
        return token;
    };
    _Tokenizer.prototype._createError = function (msg, span) {
        if (this._isInExpansionForm()) {
            msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
        }
        var error = new TokenError(msg, this._currentTokenType, span);
        this._currentTokenStart = null;
        this._currentTokenType = null;
        return new _ControlFlowError(error);
    };
    _Tokenizer.prototype.handleError = function (e) {
        if (e instanceof CursorError) {
            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
        }
        if (e instanceof _ControlFlowError) {
            this.errors.push(e.error);
        }
        else {
            throw e;
        }
    };
    _Tokenizer.prototype._attemptCharCode = function (charCode) {
        if (this._cursor.peek() === charCode) {
            this._cursor.advance();
            return true;
        }
        return false;
    };
    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {
        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
            this._cursor.advance();
            return true;
        }
        return false;
    };
    _Tokenizer.prototype._requireCharCode = function (charCode) {
        var location = this._cursor.clone();
        if (!this._attemptCharCode(charCode)) {
            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
        }
    };
    _Tokenizer.prototype._attemptStr = function (chars) {
        var len = chars.length;
        if (this._cursor.charsLeft() < len) {
            return false;
        }
        var initialPosition = this._cursor.clone();
        for (var i = 0; i < len; i++) {
            if (!this._attemptCharCode(chars.charCodeAt(i))) {
                this._cursor = initialPosition;
                return false;
            }
        }
        return true;
    };
    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {
        for (var i = 0; i < chars.length; i++) {
            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
                return false;
            }
        }
        return true;
    };
    _Tokenizer.prototype._requireStr = function (chars) {
        var location = this._cursor.clone();
        if (!this._attemptStr(chars)) {
            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
        }
    };
    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {
        while (!predicate(this._cursor.peek())) {
            this._cursor.advance();
        }
    };
    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {
        var start = this._cursor.clone();
        this._attemptCharCodeUntilFn(predicate);
        if (this._cursor.diff(start) < len) {
            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
        }
    };
    _Tokenizer.prototype._attemptUntilChar = function (char) {
        while (this._cursor.peek() !== char) {
            this._cursor.advance();
        }
    };
    _Tokenizer.prototype._readChar = function () {
        var char = String.fromCodePoint(this._cursor.peek());
        this._cursor.advance();
        return char;
    };
    _Tokenizer.prototype._consumeEntity = function (textTokenType) {
        this._beginToken(9);
        var start = this._cursor.clone();
        this._cursor.advance();
        if (this._attemptCharCode(chars.$HASH)) {
            var isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);
            var codeStart = this._cursor.clone();
            this._attemptCharCodeUntilFn(isDigitEntityEnd);
            if (this._cursor.peek() != chars.$SEMICOLON) {
                this._cursor.advance();
                var entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
                throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
            }
            var strNum = this._cursor.getChars(codeStart);
            this._cursor.advance();
            try {
                var charCode = parseInt(strNum, isHex ? 16 : 10);
                this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);
            }
            catch (_a) {
                throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
            }
        }
        else {
            var nameStart = this._cursor.clone();
            this._attemptCharCodeUntilFn(isNamedEntityEnd);
            if (this._cursor.peek() != chars.$SEMICOLON) {
                this._beginToken(textTokenType, start);
                this._cursor = nameStart;
                this._endToken(['&']);
            }
            else {
                var name_1 = this._cursor.getChars(nameStart);
                this._cursor.advance();
                var char = entities_1.NAMED_ENTITIES[name_1];
                if (!char) {
                    throw this._createError(_unknownEntityErrorMsg(name_1), this._cursor.getSpan(start));
                }
                this._endToken([char, "&".concat(name_1, ";")]);
            }
        }
    };
    _Tokenizer.prototype._consumeRawText = function (consumeEntities, endMarkerPredicate) {
        this._beginToken(consumeEntities ? 6 : 7);
        var parts = [];
        while (true) {
            var tagCloseStart = this._cursor.clone();
            var foundEndMarker = endMarkerPredicate();
            this._cursor = tagCloseStart;
            if (foundEndMarker) {
                break;
            }
            if (consumeEntities && this._cursor.peek() === chars.$AMPERSAND) {
                this._endToken([this._processCarriageReturns(parts.join(''))]);
                parts.length = 0;
                this._consumeEntity(6);
                this._beginToken(6);
            }
            else {
                parts.push(this._readChar());
            }
        }
        this._endToken([this._processCarriageReturns(parts.join(''))]);
    };
    _Tokenizer.prototype._consumeComment = function (start) {
        var _this = this;
        this._beginToken(10, start);
        this._requireCharCode(chars.$MINUS);
        this._endToken([]);
        this._consumeRawText(false, function () { return _this._attemptStr('-->'); });
        this._beginToken(11);
        this._requireStr('-->');
        this._endToken([]);
    };
    _Tokenizer.prototype._consumeCdata = function (start) {
        var _this = this;
        this._beginToken(12, start);
        this._requireStr('CDATA[');
        this._endToken([]);
        this._consumeRawText(false, function () { return _this._attemptStr(']]>'); });
        this._beginToken(13);
        this._requireStr(']]>');
        this._endToken([]);
    };
    _Tokenizer.prototype._consumeDocType = function (start) {
        this._beginToken(18, start);
        var contentStart = this._cursor.clone();
        this._attemptUntilChar(chars.$GT);
        var content = this._cursor.getChars(contentStart);
        this._cursor.advance();
        this._endToken([content]);
    };
    _Tokenizer.prototype._consumePrefixAndName = function () {
        var nameOrPrefixStart = this._cursor.clone();
        var prefix = '';
        while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {
            this._cursor.advance();
        }
        var nameStart;
        if (this._cursor.peek() === chars.$COLON) {
            prefix = this._cursor.getChars(nameOrPrefixStart);
            this._cursor.advance();
            nameStart = this._cursor.clone();
        }
        else {
            nameStart = nameOrPrefixStart;
        }
        this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);
        var name = this._cursor.getChars(nameStart);
        return [prefix, name];
    };
    _Tokenizer.prototype._consumeTagOpen = function (start) {
        var tagName;
        var prefix;
        var openTagToken;
        try {
            if (!chars.isAsciiLetter(this._cursor.peek())) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
            }
            openTagToken = this._consumeTagOpenStart(start);
            prefix = openTagToken.parts[0];
            tagName = openTagToken.parts[1];
            this._attemptCharCodeUntilFn(isNotWhitespace);
            while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT &&
                this._cursor.peek() !== chars.$LT && this._cursor.peek() !== chars.$EOF) {
                this._consumeAttributeName();
                this._attemptCharCodeUntilFn(isNotWhitespace);
                if (this._attemptCharCode(chars.$EQ)) {
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                    this._consumeAttributeValue();
                }
                this._attemptCharCodeUntilFn(isNotWhitespace);
            }
            this._consumeTagOpenEnd();
        }
        catch (e) {
            if (e instanceof _ControlFlowError) {
                if (openTagToken) {
                    openTagToken.type = 4;
                }
                else {
                    this._beginToken(5, start);
                    this._endToken(['<']);
                }
                return;
            }
            throw e;
        }
        var contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);
        if (contentTokenType === tags_1.TagContentType.RAW_TEXT) {
            this._consumeRawTextWithTagClose(prefix, tagName, false);
        }
        else if (contentTokenType === tags_1.TagContentType.ESCAPABLE_RAW_TEXT) {
            this._consumeRawTextWithTagClose(prefix, tagName, true);
        }
    };
    _Tokenizer.prototype._consumeRawTextWithTagClose = function (prefix, tagName, consumeEntities) {
        var _this = this;
        this._consumeRawText(consumeEntities, function () {
            if (!_this._attemptCharCode(chars.$LT))
                return false;
            if (!_this._attemptCharCode(chars.$SLASH))
                return false;
            _this._attemptCharCodeUntilFn(isNotWhitespace);
            if (!_this._attemptStrCaseInsensitive(tagName))
                return false;
            _this._attemptCharCodeUntilFn(isNotWhitespace);
            return _this._attemptCharCode(chars.$GT);
        });
        this._beginToken(3);
        this._requireCharCodeUntilFn(function (code) { return code === chars.$GT; }, 3);
        this._cursor.advance();
        this._endToken([prefix, tagName]);
    };
    _Tokenizer.prototype._consumeTagOpenStart = function (start) {
        this._beginToken(0, start);
        var parts = this._consumePrefixAndName();
        return this._endToken(parts);
    };
    _Tokenizer.prototype._consumeAttributeName = function () {
        var attrNameStart = this._cursor.peek();
        if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {
            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
        }
        this._beginToken(14);
        var prefixAndName = this._consumePrefixAndName();
        this._endToken(prefixAndName);
    };
    _Tokenizer.prototype._consumeAttributeValue = function () {
        var _this = this;
        if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {
            var quoteChar_1 = this._cursor.peek();
            this._consumeQuote(quoteChar_1);
            var endPredicate = function () { return _this._cursor.peek() === quoteChar_1; };
            this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);
            this._consumeQuote(quoteChar_1);
        }
        else {
            var endPredicate = function () { return isNameEnd(_this._cursor.peek()); };
            this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);
        }
    };
    _Tokenizer.prototype._consumeQuote = function (quoteChar) {
        this._beginToken(15);
        this._requireCharCode(quoteChar);
        this._endToken([String.fromCodePoint(quoteChar)]);
    };
    _Tokenizer.prototype._consumeTagOpenEnd = function () {
        var tokenType = this._attemptCharCode(chars.$SLASH) ? 2 : 1;
        this._beginToken(tokenType);
        this._requireCharCode(chars.$GT);
        this._endToken([]);
    };
    _Tokenizer.prototype._consumeTagClose = function (start) {
        this._beginToken(3, start);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        var prefixAndName = this._consumePrefixAndName();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._requireCharCode(chars.$GT);
        this._endToken(prefixAndName);
    };
    _Tokenizer.prototype._consumeExpansionFormStart = function () {
        this._beginToken(19);
        this._requireCharCode(chars.$LBRACE);
        this._endToken([]);
        this._expansionCaseStack.push(19);
        this._beginToken(7);
        var condition = this._readUntil(chars.$COMMA);
        var normalizedCondition = this._processCarriageReturns(condition);
        if (this._i18nNormalizeLineEndingsInICUs) {
            this._endToken([normalizedCondition]);
        }
        else {
            var conditionToken = this._endToken([condition]);
            if (normalizedCondition !== condition) {
                this.nonNormalizedIcuExpressions.push(conditionToken);
            }
        }
        this._requireCharCode(chars.$COMMA);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._beginToken(7);
        var type = this._readUntil(chars.$COMMA);
        this._endToken([type]);
        this._requireCharCode(chars.$COMMA);
        this._attemptCharCodeUntilFn(isNotWhitespace);
    };
    _Tokenizer.prototype._consumeExpansionCaseStart = function () {
        this._beginToken(20);
        var value = this._readUntil(chars.$LBRACE).trim();
        this._endToken([value]);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._beginToken(21);
        this._requireCharCode(chars.$LBRACE);
        this._endToken([]);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._expansionCaseStack.push(21);
    };
    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {
        this._beginToken(22);
        this._requireCharCode(chars.$RBRACE);
        this._endToken([]);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._expansionCaseStack.pop();
    };
    _Tokenizer.prototype._consumeExpansionFormEnd = function () {
        this._beginToken(23);
        this._requireCharCode(chars.$RBRACE);
        this._endToken([]);
        this._expansionCaseStack.pop();
    };
    _Tokenizer.prototype._consumeWithInterpolation = function (textTokenType, interpolationTokenType, endPredicate, endInterpolation) {
        this._beginToken(textTokenType);
        var parts = [];
        while (!endPredicate()) {
            var current = this._cursor.clone();
            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
                this._endToken([this._processCarriageReturns(parts.join(''))], current);
                parts.length = 0;
                this._consumeInterpolation(interpolationTokenType, current, endInterpolation);
                this._beginToken(textTokenType);
            }
            else if (this._cursor.peek() === chars.$AMPERSAND) {
                this._endToken([this._processCarriageReturns(parts.join(''))]);
                parts.length = 0;
                this._consumeEntity(textTokenType);
                this._beginToken(textTokenType);
            }
            else {
                parts.push(this._readChar());
            }
        }
        this._inInterpolation = false;
        this._endToken([this._processCarriageReturns(parts.join(''))]);
    };
    _Tokenizer.prototype._consumeInterpolation = function (interpolationTokenType, interpolationStart, prematureEndPredicate) {
        var parts = [];
        this._beginToken(interpolationTokenType, interpolationStart);
        parts.push(this._interpolationConfig.start);
        var expressionStart = this._cursor.clone();
        var inQuote = null;
        var inComment = false;
        while (this._cursor.peek() !== chars.$EOF &&
            (prematureEndPredicate === null || !prematureEndPredicate())) {
            var current = this._cursor.clone();
            if (this._isTagStart()) {
                this._cursor = current;
                parts.push(this._getProcessedChars(expressionStart, current));
                this._endToken(parts);
                return;
            }
            if (inQuote === null) {
                if (this._attemptStr(this._interpolationConfig.end)) {
                    parts.push(this._getProcessedChars(expressionStart, current));
                    parts.push(this._interpolationConfig.end);
                    this._endToken(parts);
                    return;
                }
                else if (this._attemptStr('//')) {
                    inComment = true;
                }
            }
            var char = this._cursor.peek();
            this._cursor.advance();
            if (char === chars.$BACKSLASH) {
                this._cursor.advance();
            }
            else if (char === inQuote) {
                inQuote = null;
            }
            else if (!inComment && inQuote === null && chars.isQuote(char)) {
                inQuote = char;
            }
        }
        parts.push(this._getProcessedChars(expressionStart, this._cursor));
        this._endToken(parts);
    };
    _Tokenizer.prototype._getProcessedChars = function (start, end) {
        return this._processCarriageReturns(end.getChars(start));
    };
    _Tokenizer.prototype._isTextEnd = function () {
        if (this._isTagStart() || this._isBlockStart() || this._cursor.peek() === chars.$EOF) {
            return true;
        }
        if (this._tokenizeIcu && !this._inInterpolation) {
            if (this.isExpansionFormStart()) {
                return true;
            }
            if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {
                return true;
            }
        }
        return false;
    };
    _Tokenizer.prototype._isTagStart = function () {
        if (this._cursor.peek() === chars.$LT) {
            var tmp = this._cursor.clone();
            tmp.advance();
            var code = tmp.peek();
            if ((chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||
                code === chars.$SLASH || code === chars.$BANG) {
                return true;
            }
        }
        return false;
    };
    _Tokenizer.prototype._isBlockStart = function () {
        if (this._tokenizeBlocks && this._cursor.peek() === chars.$LBRACE) {
            var tmp = this._cursor.clone();
            tmp.advance();
            var next = tmp.peek();
            if (next !== chars.$BANG && next !== chars.$SLASH && next !== chars.$COLON) {
                return false;
            }
            tmp.advance();
            if (isBlockNameChar(tmp.peek())) {
                return true;
            }
        }
        return false;
    };
    _Tokenizer.prototype._readUntil = function (char) {
        var start = this._cursor.clone();
        this._attemptUntilChar(char);
        return this._cursor.getChars(start);
    };
    _Tokenizer.prototype._isInExpansionCase = function () {
        return this._expansionCaseStack.length > 0 &&
            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                21;
    };
    _Tokenizer.prototype._isInExpansionForm = function () {
        return this._expansionCaseStack.length > 0 &&
            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                19;
    };
    _Tokenizer.prototype.isExpansionFormStart = function () {
        if (this._cursor.peek() !== chars.$LBRACE) {
            return false;
        }
        if (this._interpolationConfig) {
            var start = this._cursor.clone();
            var isInterpolation = this._attemptStr(this._interpolationConfig.start);
            this._cursor = start;
            return !isInterpolation;
        }
        return true;
    };
    return _Tokenizer;
}());
function isNotWhitespace(code) {
    return !chars.isWhitespace(code) || code === chars.$EOF;
}
function isNameEnd(code) {
    return chars.isWhitespace(code) || code === chars.$GT || code === chars.$LT ||
        code === chars.$SLASH || code === chars.$SQ || code === chars.$DQ || code === chars.$EQ ||
        code === chars.$EOF;
}
function isPrefixEnd(code) {
    return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&
        (code < chars.$0 || code > chars.$9);
}
function isDigitEntityEnd(code) {
    return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiHexDigit(code);
}
function isNamedEntityEnd(code) {
    return code === chars.$SEMICOLON || code === chars.$EOF || !chars.isAsciiLetter(code);
}
function isExpansionCaseStart(peek) {
    return peek !== chars.$RBRACE;
}
function compareCharCodeCaseInsensitive(code1, code2) {
    return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);
}
function toUpperCaseCharCode(code) {
    return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;
}
function isBlockNameChar(code) {
    return chars.isAsciiLetter(code) || chars.isDigit(code) || code === chars.$_;
}
function isBlockParameterChar(code) {
    return code !== chars.$SEMICOLON && isNotWhitespace(code);
}
function mergeTextTokens(srcTokens) {
    var dstTokens = [];
    var lastDstToken = undefined;
    for (var i = 0; i < srcTokens.length; i++) {
        var token = srcTokens[i];
        if ((lastDstToken && lastDstToken.type === 5 && token.type === 5) ||
            (lastDstToken && lastDstToken.type === 16 &&
                token.type === 16)) {
            lastDstToken.parts[0] += token.parts[0];
            lastDstToken.sourceSpan.end = token.sourceSpan.end;
        }
        else {
            lastDstToken = token;
            dstTokens.push(lastDstToken);
        }
    }
    return dstTokens;
}
var PlainCharacterCursor = (function () {
    function PlainCharacterCursor(fileOrCursor, range) {
        if (fileOrCursor instanceof PlainCharacterCursor) {
            this.file = fileOrCursor.file;
            this.input = fileOrCursor.input;
            this.end = fileOrCursor.end;
            var state = fileOrCursor.state;
            this.state = {
                peek: state.peek,
                offset: state.offset,
                line: state.line,
                column: state.column,
            };
        }
        else {
            if (!range) {
                throw new Error('Programming error: the range argument must be provided with a file argument.');
            }
            this.file = fileOrCursor;
            this.input = fileOrCursor.content;
            this.end = range.endPos;
            this.state = {
                peek: -1,
                offset: range.startPos,
                line: range.startLine,
                column: range.startCol,
            };
        }
    }
    PlainCharacterCursor.prototype.clone = function () {
        return new PlainCharacterCursor(this);
    };
    PlainCharacterCursor.prototype.peek = function () {
        return this.state.peek;
    };
    PlainCharacterCursor.prototype.charsLeft = function () {
        return this.end - this.state.offset;
    };
    PlainCharacterCursor.prototype.diff = function (other) {
        return this.state.offset - other.state.offset;
    };
    PlainCharacterCursor.prototype.advance = function () {
        this.advanceState(this.state);
    };
    PlainCharacterCursor.prototype.init = function () {
        this.updatePeek(this.state);
    };
    PlainCharacterCursor.prototype.getSpan = function (start, leadingTriviaCodePoints) {
        start = start || this;
        var fullStart = start;
        if (leadingTriviaCodePoints) {
            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
                if (fullStart === start) {
                    start = start.clone();
                }
                start.advance();
            }
        }
        var startLocation = this.locationFromCursor(start);
        var endLocation = this.locationFromCursor(this);
        var fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
        return new parse_util_1.ParseSourceSpan(startLocation, endLocation, fullStartLocation);
    };
    PlainCharacterCursor.prototype.getChars = function (start) {
        return this.input.substring(start.state.offset, this.state.offset);
    };
    PlainCharacterCursor.prototype.charAt = function (pos) {
        return this.input.charCodeAt(pos);
    };
    PlainCharacterCursor.prototype.advanceState = function (state) {
        if (state.offset >= this.end) {
            this.state = state;
            throw new CursorError('Unexpected character "EOF"', this);
        }
        var currentChar = this.charAt(state.offset);
        if (currentChar === chars.$LF) {
            state.line++;
            state.column = 0;
        }
        else if (!chars.isNewLine(currentChar)) {
            state.column++;
        }
        state.offset++;
        this.updatePeek(state);
    };
    PlainCharacterCursor.prototype.updatePeek = function (state) {
        state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);
    };
    PlainCharacterCursor.prototype.locationFromCursor = function (cursor) {
        return new parse_util_1.ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
    };
    return PlainCharacterCursor;
}());
var EscapedCharacterCursor = (function (_super) {
    __extends(EscapedCharacterCursor, _super);
    function EscapedCharacterCursor(fileOrCursor, range) {
        var _this = this;
        if (fileOrCursor instanceof EscapedCharacterCursor) {
            _this = _super.call(this, fileOrCursor) || this;
            _this.internalState = __assign({}, fileOrCursor.internalState);
        }
        else {
            _this = _super.call(this, fileOrCursor, range) || this;
            _this.internalState = _this.state;
        }
        return _this;
    }
    EscapedCharacterCursor.prototype.advance = function () {
        this.state = this.internalState;
        _super.prototype.advance.call(this);
        this.processEscapeSequence();
    };
    EscapedCharacterCursor.prototype.init = function () {
        _super.prototype.init.call(this);
        this.processEscapeSequence();
    };
    EscapedCharacterCursor.prototype.clone = function () {
        return new EscapedCharacterCursor(this);
    };
    EscapedCharacterCursor.prototype.getChars = function (start) {
        var cursor = start.clone();
        var chars = '';
        while (cursor.internalState.offset < this.internalState.offset) {
            chars += String.fromCodePoint(cursor.peek());
            cursor.advance();
        }
        return chars;
    };
    EscapedCharacterCursor.prototype.processEscapeSequence = function () {
        var _this = this;
        var peek = function () { return _this.internalState.peek; };
        if (peek() === chars.$BACKSLASH) {
            this.internalState = __assign({}, this.state);
            this.advanceState(this.internalState);
            if (peek() === chars.$n) {
                this.state.peek = chars.$LF;
            }
            else if (peek() === chars.$r) {
                this.state.peek = chars.$CR;
            }
            else if (peek() === chars.$v) {
                this.state.peek = chars.$VTAB;
            }
            else if (peek() === chars.$t) {
                this.state.peek = chars.$TAB;
            }
            else if (peek() === chars.$b) {
                this.state.peek = chars.$BSPACE;
            }
            else if (peek() === chars.$f) {
                this.state.peek = chars.$FF;
            }
            else if (peek() === chars.$u) {
                this.advanceState(this.internalState);
                if (peek() === chars.$LBRACE) {
                    this.advanceState(this.internalState);
                    var digitStart = this.clone();
                    var length_1 = 0;
                    while (peek() !== chars.$RBRACE) {
                        this.advanceState(this.internalState);
                        length_1++;
                    }
                    this.state.peek = this.decodeHexDigits(digitStart, length_1);
                }
                else {
                    var digitStart = this.clone();
                    this.advanceState(this.internalState);
                    this.advanceState(this.internalState);
                    this.advanceState(this.internalState);
                    this.state.peek = this.decodeHexDigits(digitStart, 4);
                }
            }
            else if (peek() === chars.$x) {
                this.advanceState(this.internalState);
                var digitStart = this.clone();
                this.advanceState(this.internalState);
                this.state.peek = this.decodeHexDigits(digitStart, 2);
            }
            else if (chars.isOctalDigit(peek())) {
                var octal = '';
                var length_2 = 0;
                var previous = this.clone();
                while (chars.isOctalDigit(peek()) && length_2 < 3) {
                    previous = this.clone();
                    octal += String.fromCodePoint(peek());
                    this.advanceState(this.internalState);
                    length_2++;
                }
                this.state.peek = parseInt(octal, 8);
                this.internalState = previous.internalState;
            }
            else if (chars.isNewLine(this.internalState.peek)) {
                this.advanceState(this.internalState);
                this.state = this.internalState;
            }
            else {
                this.state.peek = this.internalState.peek;
            }
        }
    };
    EscapedCharacterCursor.prototype.decodeHexDigits = function (start, length) {
        var hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);
        var charCode = parseInt(hex, 16);
        if (!isNaN(charCode)) {
            return charCode;
        }
        else {
            start.state = start.internalState;
            throw new CursorError('Invalid hexadecimal escape sequence', start);
        }
    };
    return EscapedCharacterCursor;
}(PlainCharacterCursor));
var CursorError = (function () {
    function CursorError(msg, cursor) {
        this.msg = msg;
        this.cursor = cursor;
    }
    return CursorError;
}());
exports.CursorError = CursorError;
