"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addOverriddenComponents = exports.getComponentStatistics = exports.getComponentCountInSourceFiles = exports.mergeObjects = void 0;
var lodash_1 = require("lodash");
var import_declarations_1 = require("./import-declarations");
var names_1 = require("./names");
function mergeObjects() {
    var input = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        input[_i] = arguments[_i];
    }
    var projectCount = lodash_1.mergeWith.apply(void 0, __spreadArray(__spreadArray([{}], __read(input), false), [function (objValue, srcValue) {
            var sum;
            if (typeof objValue === "number" && typeof srcValue === "number") {
                sum = objValue + srcValue;
            }
            return sum;
        }], false));
    return projectCount;
}
exports.mergeObjects = mergeObjects;
function getComponentCountInSourceFiles(_a) {
    var componentName = _a.componentName, sourceFiles = _a.sourceFiles, projectPath = _a.projectPath;
    return sourceFiles.reduce(function (acc, sourceFile) {
        var _a;
        var aliasDict = {};
        var elementNames = [];
        var importDeclaration = sourceFile.getImportDeclaration(function (ele) { return (0, import_declarations_1.hasComponent)(ele, componentName); });
        if (importDeclaration !== undefined) {
            aliasDict = (0, names_1.getImportAlias)(importDeclaration);
            elementNames = (0, names_1.getJSXElementNames)(sourceFile).filter(function (ele) { return aliasDict[ele] !== undefined || ele === componentName; });
        }
        var relativePath = (0, names_1.getPathRelativeToRoot)(sourceFile, projectPath);
        var elementCount = elementNames.length;
        var output = acc;
        if (elementCount > 0) {
            output = __assign(__assign({}, acc), (_a = {}, _a[relativePath] = elementCount, _a));
        }
        return output;
    }, {});
}
exports.getComponentCountInSourceFiles = getComponentCountInSourceFiles;
function getComponentStatistics(importedComponents, selfDeclaredComponent) {
    var thirdPartyComponents = importedComponents.length;
    var selfDeclaredComponents = selfDeclaredComponent.length;
    var totalComponents = thirdPartyComponents + selfDeclaredComponents;
    var allComponents = __spreadArray(__spreadArray([], __read(importedComponents), false), __read(selfDeclaredComponent), false);
    var _a = __read((0, lodash_1.partition)(allComponents, function (component) { return component.designSystems.length > 0; }), 2), withDesignSystem = _a[0], withoutDesignSystem = _a[1];
    var designSystemsComponents = withDesignSystem.length;
    var nonDesignSystemComponents = withoutDesignSystem.length;
    var coverage = designSystemsComponents / totalComponents;
    return {
        thirdPartyComponents: thirdPartyComponents,
        selfDeclaredComponents: selfDeclaredComponents,
        designSystemsComponents: designSystemsComponents,
        nonDesignSystemComponents: nonDesignSystemComponents,
        totalComponents: totalComponents,
        coverage: coverage,
    };
}
exports.getComponentStatistics = getComponentStatistics;
function getOverriddenByDictionary(components) {
    var invertedMapping = {};
    for (var filePath in components) {
        var componentsUsed = components[filePath];
        for (var componentName in componentsUsed) {
            if (!invertedMapping[componentName]) {
                invertedMapping[componentName] = {};
            }
            invertedMapping[componentName][filePath] = componentsUsed[componentName];
        }
    }
    return invertedMapping;
}
function addOverriddenComponents(importedComponents, selfDeclaredComponents) {
    var overriddenComponents = selfDeclaredComponents.reduce(function (acc, ele) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[ele.id] = ele.overriddenComponents, _a)));
    }, {});
    var overriddenByDictionary = getOverriddenByDictionary(overriddenComponents);
    var updatedComponents = importedComponents.map(function (component) { return (__assign(__assign({}, component), { overriddenBy: overriddenByDictionary[component.id] })); });
    return updatedComponents;
}
exports.addOverriddenComponents = addOverriddenComponents;
