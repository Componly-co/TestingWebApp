import { OpKind } from './enums';
export type XrefId = number & {
    __brand: 'XrefId';
};
export interface Op<OpT extends Op<OpT>> {
    kind: OpKind;
    prev: OpT | null;
    next: OpT | null;
    debugListId: number | null;
}
export declare class OpList<OpT extends Op<OpT>> {
    static nextListId: number;
    readonly debugListId: number;
    readonly head: OpT;
    readonly tail: OpT;
    constructor();
    push(op: OpT): void;
    prepend(ops: OpT[]): void;
    [Symbol.iterator](): Generator<OpT>;
    reversed(): Generator<OpT>;
    static replace<OpT extends Op<OpT>>(oldOp: OpT, newOp: OpT): void;
    static replaceWithMany<OpT extends Op<OpT>>(oldOp: OpT, newOps: OpT[]): void;
    static remove<OpT extends Op<OpT>>(op: OpT): void;
    static insertBefore<OpT extends Op<OpT>>(op: OpT, target: OpT): void;
    static insertAfter<OpT extends Op<OpT>>(op: OpT, target: OpT): void;
    static assertIsUnowned<OpT extends Op<OpT>>(op: OpT): void;
    static assertIsOwned<OpT extends Op<OpT>>(op: OpT, byList?: number): void;
    static assertIsNotEnd<OpT extends Op<OpT>>(op: OpT): void;
}
//# sourceMappingURL=operations.d.ts.map