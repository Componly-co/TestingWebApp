import * as o from '../../../../output/output_ast';
import type { ParseSourceSpan } from '../../../../parse_util';
import { ExpressionKind, SanitizerFn } from './enums';
import { ConsumesVarsTrait, UsesSlotIndex, UsesSlotIndexTrait, UsesVarOffset, UsesVarOffsetTrait } from './traits';
import type { XrefId } from './operations';
import type { CreateOp } from './ops/create';
import { type UpdateOp } from './ops/update';
export type Expression = LexicalReadExpr | ReferenceExpr | ContextExpr | NextContextExpr | GetCurrentViewExpr | RestoreViewExpr | ResetViewExpr | ReadVariableExpr | PureFunctionExpr | PureFunctionParameterExpr | PipeBindingExpr | PipeBindingVariadicExpr | SafePropertyReadExpr | SafeKeyedReadExpr | SafeInvokeFunctionExpr | EmptyExpr | AssignTemporaryExpr | ReadTemporaryExpr | SanitizerExpr;
export type ExpressionTransform = (expr: o.Expression, flags: VisitorContextFlag) => o.Expression;
export declare function isIrExpression(expr: o.Expression): expr is Expression;
export declare abstract class ExpressionBase extends o.Expression {
    abstract readonly kind: ExpressionKind;
    constructor(sourceSpan?: ParseSourceSpan | null);
    abstract transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
}
export declare class LexicalReadExpr extends ExpressionBase {
    readonly name: string;
    readonly kind = ExpressionKind.LexicalRead;
    constructor(name: string);
    visitExpression(visitor: o.ExpressionVisitor, context: any): void;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(): void;
    clone(): LexicalReadExpr;
}
export declare class ReferenceExpr extends ExpressionBase implements UsesSlotIndexTrait {
    readonly target: XrefId;
    readonly offset: number;
    readonly kind = ExpressionKind.Reference;
    readonly [UsesSlotIndex] = true;
    slot: number | null;
    constructor(target: XrefId, offset: number);
    visitExpression(): void;
    isEquivalent(e: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(): void;
    clone(): ReferenceExpr;
}
export declare class ContextExpr extends ExpressionBase {
    readonly view: XrefId;
    readonly kind = ExpressionKind.Context;
    constructor(view: XrefId);
    visitExpression(): void;
    isEquivalent(e: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(): void;
    clone(): ContextExpr;
}
export declare class NextContextExpr extends ExpressionBase {
    readonly kind = ExpressionKind.NextContext;
    steps: number;
    constructor();
    visitExpression(): void;
    isEquivalent(e: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(): void;
    clone(): NextContextExpr;
}
export declare class GetCurrentViewExpr extends ExpressionBase {
    readonly kind = ExpressionKind.GetCurrentView;
    constructor();
    visitExpression(): void;
    isEquivalent(e: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(): void;
    clone(): GetCurrentViewExpr;
}
export declare class RestoreViewExpr extends ExpressionBase {
    view: XrefId | o.Expression;
    readonly kind = ExpressionKind.RestoreView;
    constructor(view: XrefId | o.Expression);
    visitExpression(visitor: o.ExpressionVisitor, context: any): void;
    isEquivalent(e: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): RestoreViewExpr;
}
export declare class ResetViewExpr extends ExpressionBase {
    expr: o.Expression;
    readonly kind = ExpressionKind.ResetView;
    constructor(expr: o.Expression);
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(e: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): ResetViewExpr;
}
export declare class ReadVariableExpr extends ExpressionBase {
    readonly xref: XrefId;
    readonly kind = ExpressionKind.ReadVariable;
    name: string | null;
    constructor(xref: XrefId);
    visitExpression(): void;
    isEquivalent(other: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(): void;
    clone(): ReadVariableExpr;
}
export declare class PureFunctionExpr extends ExpressionBase implements ConsumesVarsTrait, UsesVarOffsetTrait {
    readonly kind = ExpressionKind.PureFunctionExpr;
    readonly [ConsumesVarsTrait] = true;
    readonly [UsesVarOffset] = true;
    varOffset: number | null;
    body: o.Expression | null;
    args: o.Expression[];
    fn: o.Expression | null;
    constructor(expression: o.Expression | null, args: o.Expression[]);
    visitExpression(visitor: o.ExpressionVisitor, context: any): void;
    isEquivalent(other: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): PureFunctionExpr;
}
export declare class PureFunctionParameterExpr extends ExpressionBase {
    index: number;
    readonly kind = ExpressionKind.PureFunctionParameterExpr;
    constructor(index: number);
    visitExpression(): void;
    isEquivalent(other: o.Expression): boolean;
    isConstant(): boolean;
    transformInternalExpressions(): void;
    clone(): PureFunctionParameterExpr;
}
export declare class PipeBindingExpr extends ExpressionBase implements UsesSlotIndexTrait, ConsumesVarsTrait, UsesVarOffsetTrait {
    readonly target: XrefId;
    readonly name: string;
    readonly args: o.Expression[];
    readonly kind = ExpressionKind.PipeBinding;
    readonly [UsesSlotIndex] = true;
    readonly [ConsumesVarsTrait] = true;
    readonly [UsesVarOffset] = true;
    slot: number | null;
    varOffset: number | null;
    constructor(target: XrefId, name: string, args: o.Expression[]);
    visitExpression(visitor: o.ExpressionVisitor, context: any): void;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): PipeBindingExpr;
}
export declare class PipeBindingVariadicExpr extends ExpressionBase implements UsesSlotIndexTrait, ConsumesVarsTrait, UsesVarOffsetTrait {
    readonly target: XrefId;
    readonly name: string;
    args: o.Expression;
    numArgs: number;
    readonly kind = ExpressionKind.PipeBindingVariadic;
    readonly [UsesSlotIndex] = true;
    readonly [ConsumesVarsTrait] = true;
    readonly [UsesVarOffset] = true;
    slot: number | null;
    varOffset: number | null;
    constructor(target: XrefId, name: string, args: o.Expression, numArgs: number);
    visitExpression(visitor: o.ExpressionVisitor, context: any): void;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): PipeBindingVariadicExpr;
}
export declare class SafePropertyReadExpr extends ExpressionBase {
    receiver: o.Expression;
    name: string;
    readonly kind = ExpressionKind.SafePropertyRead;
    constructor(receiver: o.Expression, name: string);
    get index(): string;
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): SafePropertyReadExpr;
}
export declare class SafeKeyedReadExpr extends ExpressionBase {
    receiver: o.Expression;
    index: o.Expression;
    readonly kind = ExpressionKind.SafeKeyedRead;
    constructor(receiver: o.Expression, index: o.Expression);
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): SafeKeyedReadExpr;
}
export declare class SafeInvokeFunctionExpr extends ExpressionBase {
    receiver: o.Expression;
    args: o.Expression[];
    readonly kind = ExpressionKind.SafeInvokeFunction;
    constructor(receiver: o.Expression, args: o.Expression[]);
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): SafeInvokeFunctionExpr;
}
export declare class SafeTernaryExpr extends ExpressionBase {
    guard: o.Expression;
    expr: o.Expression;
    readonly kind = ExpressionKind.SafeTernaryExpr;
    constructor(guard: o.Expression, expr: o.Expression);
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): SafeTernaryExpr;
}
export declare class EmptyExpr extends ExpressionBase {
    readonly kind = ExpressionKind.EmptyExpr;
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(e: Expression): boolean;
    isConstant(): boolean;
    clone(): EmptyExpr;
    transformInternalExpressions(): void;
}
export declare class AssignTemporaryExpr extends ExpressionBase {
    expr: o.Expression;
    xref: XrefId;
    readonly kind = ExpressionKind.AssignTemporaryExpr;
    name: string | null;
    constructor(expr: o.Expression, xref: XrefId);
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): AssignTemporaryExpr;
}
export declare class ReadTemporaryExpr extends ExpressionBase {
    xref: XrefId;
    readonly kind = ExpressionKind.ReadTemporaryExpr;
    name: string | null;
    constructor(xref: XrefId);
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(): boolean;
    isConstant(): boolean;
    transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag): void;
    clone(): ReadTemporaryExpr;
}
export declare class SanitizerExpr extends ExpressionBase {
    fn: SanitizerFn;
    readonly kind = ExpressionKind.SanitizerExpr;
    constructor(fn: SanitizerFn);
    visitExpression(visitor: o.ExpressionVisitor, context: any): any;
    isEquivalent(e: Expression): boolean;
    isConstant(): boolean;
    clone(): SanitizerExpr;
    transformInternalExpressions(): void;
}
export declare function visitExpressionsInOp(op: CreateOp | UpdateOp, visitor: (expr: o.Expression, flags: VisitorContextFlag) => void): void;
export declare enum VisitorContextFlag {
    None = 0,
    InChildOperation = 1
}
export declare function transformExpressionsInOp(op: CreateOp | UpdateOp, transform: ExpressionTransform, flags: VisitorContextFlag): void;
export declare function transformExpressionsInExpression(expr: o.Expression, transform: ExpressionTransform, flags: VisitorContextFlag): o.Expression;
export declare function transformExpressionsInStatement(stmt: o.Statement, transform: ExpressionTransform, flags: VisitorContextFlag): void;
export declare function isStringLiteral(expr: o.Expression): expr is o.LiteralExpr & {
    value: string;
};
//# sourceMappingURL=expression.d.ts.map