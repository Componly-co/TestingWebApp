import * as o from '../output/output_ast';
export declare function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType;
export interface R3Reference {
    value: o.Expression;
    type: o.Expression;
}
export interface R3CompiledExpression {
    expression: o.Expression;
    type: o.Type;
    statements: o.Statement[];
}
export declare function prepareSyntheticPropertyName(name: string): string;
export declare function prepareSyntheticListenerName(name: string, phase: string): string;
export declare function getSafePropertyAccessString(accessor: string, name: string): string;
export declare function prepareSyntheticListenerFunctionName(name: string, phase: string): string;
export declare function jitOnlyGuardedExpression(expr: o.Expression): o.Expression;
export declare function devOnlyGuardedExpression(expr: o.Expression): o.Expression;
export declare function guardedExpression(guard: string, expr: o.Expression): o.Expression;
export declare function wrapReference(value: any): R3Reference;
export declare function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression;
export interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {
    expression: T;
    forwardRef: ForwardRefHandling;
}
export declare function createMayBeForwardRefExpression<T extends o.Expression>(expression: T, forwardRef: ForwardRefHandling): MaybeForwardRefExpression<T>;
export declare function convertFromMaybeForwardRefExpression({ expression, forwardRef }: MaybeForwardRefExpression): o.Expression;
export declare function generateForwardRef(expr: o.Expression): o.Expression;
export declare const enum ForwardRefHandling {
    None = 0,
    Wrapped = 1,
    Unwrapped = 2
}
//# sourceMappingURL=util.d.ts.map