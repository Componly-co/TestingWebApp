import { ConstantPool } from '../../constant_pool';
import { Interpolation } from '../../expression_parser/ast';
import * as o from '../../output/output_ast';
import { ParseSourceSpan } from '../../parse_util';
import * as t from '../r3_ast';
import { R3QueryMetadata } from './api';
export declare const TEMPORARY_NAME = "_t";
export declare const CONTEXT_NAME = "ctx";
export declare const RENDER_FLAGS = "rf";
export declare const REFERENCE_PREFIX = "_r";
export declare const IMPLICIT_REFERENCE = "$implicit";
export declare const NON_BINDABLE_ATTR = "ngNonBindable";
export declare const RESTORED_VIEW_CONTEXT_NAME = "restoredCtx";
export declare const DIRECT_CONTEXT_REFERENCE = "#context";
export type InstructionParams = (o.Expression | o.Expression[]) | (() => (o.Expression | o.Expression[]));
export interface Instruction {
    span: ParseSourceSpan | null;
    reference: o.ExternalReference;
    paramsOrFn?: InstructionParams;
}
export declare function invokeInstruction(span: ParseSourceSpan | null, reference: o.ExternalReference, params: o.Expression[]): o.Expression;
export declare function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr;
export declare function invalid<T>(this: t.Visitor, arg: o.Expression | o.Statement | t.Node): never;
export declare function asLiteral(value: any): o.Expression;
export declare function conditionallyCreateDirectiveBindingLiteral(map: Record<string, string | {
    classPropertyName: string;
    bindingPropertyName: string;
    transformFunction: o.Expression | null;
}>, keepDeclared?: boolean): o.Expression | null;
export declare function trimTrailingNulls(parameters: o.Expression[]): o.Expression[];
export declare function getQueryPredicate(query: R3QueryMetadata, constantPool: ConstantPool): o.Expression;
export declare class DefinitionMap<T = any> {
    values: {
        key: string;
        quoted: boolean;
        value: o.Expression;
    }[];
    set(key: keyof T, value: o.Expression | null): void;
    toLiteralMap(): o.LiteralMapExpr;
}
export declare function getAttrsForDirectiveMatching(elOrTpl: t.Element | t.Template): {
    [name: string]: string;
};
export declare function getInterpolationArgsLength(interpolation: Interpolation): number;
export declare function getInstructionStatements(instructions: Instruction[]): o.Statement[];
//# sourceMappingURL=util.d.ts.map