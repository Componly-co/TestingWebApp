import { AST } from '../../../expression_parser/ast';
import * as i18n from '../../../i18n/i18n_ast';
import * as o from '../../../output/output_ast';
export declare class I18nContext {
    readonly index: number;
    readonly ref: o.ReadVarExpr;
    readonly level: number;
    readonly templateIndex: number | null;
    readonly meta: i18n.I18nMeta;
    private registry?;
    readonly id: number;
    bindings: Set<AST>;
    placeholders: Map<string, any[]>;
    isEmitted: boolean;
    private _registry;
    private _unresolvedCtxCount;
    constructor(index: number, ref: o.ReadVarExpr, level: number, templateIndex: number | null, meta: i18n.I18nMeta, registry?: any);
    private appendTag;
    get icus(): any;
    get isRoot(): boolean;
    get isResolved(): boolean;
    getSerializedPlaceholders(): Map<string, any[]>;
    appendBinding(binding: AST): void;
    appendIcu(name: string, ref: o.Expression): void;
    appendBoundText(node: i18n.I18nMeta): void;
    appendTemplate(node: i18n.I18nMeta, index: number): void;
    appendElement(node: i18n.I18nMeta, index: number, closed?: boolean): void;
    appendProjection(node: i18n.I18nMeta, index: number): void;
    forkChildContext(index: number, templateIndex: number, meta: i18n.I18nMeta): I18nContext;
    reconcileChildContext(context: I18nContext): void;
}
//# sourceMappingURL=context.d.ts.map