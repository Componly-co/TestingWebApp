import { InterpolationConfig } from '../ml_parser/interpolation_config';
import { InterpolatedAttributeToken, InterpolatedTextToken } from '../ml_parser/tokens';
import { AbsoluteSourceSpan, AST, ASTWithSource, BindingPipe, LiteralMap, ParserError, ParseSpan, TemplateBinding, TemplateBindingIdentifier } from './ast';
import { Lexer, Token } from './lexer';
export interface InterpolationPiece {
    text: string;
    start: number;
    end: number;
}
export declare class SplitInterpolation {
    strings: InterpolationPiece[];
    expressions: InterpolationPiece[];
    offsets: number[];
    constructor(strings: InterpolationPiece[], expressions: InterpolationPiece[], offsets: number[]);
}
export declare class TemplateBindingParseResult {
    templateBindings: TemplateBinding[];
    warnings: string[];
    errors: ParserError[];
    constructor(templateBindings: TemplateBinding[], warnings: string[], errors: ParserError[]);
}
export declare const enum ParseFlags {
    None = 0,
    Action = 1,
    AssignmentEvent = 2
}
export declare class Parser {
    private _lexer;
    private errors;
    constructor(_lexer: Lexer);
    parseAction(input: string, isAssignmentEvent: boolean, location: string, absoluteOffset: number, interpolationConfig?: InterpolationConfig): ASTWithSource;
    parseBinding(input: string, location: string, absoluteOffset: number, interpolationConfig?: InterpolationConfig): ASTWithSource;
    private checkSimpleExpression;
    parseSimpleBinding(input: string, location: string, absoluteOffset: number, interpolationConfig?: InterpolationConfig): ASTWithSource;
    private _reportError;
    private _parseBindingAst;
    parseTemplateBindings(templateKey: string, templateValue: string, templateUrl: string, absoluteKeyOffset: number, absoluteValueOffset: number): TemplateBindingParseResult;
    parseInterpolation(input: string, location: string, absoluteOffset: number, interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null, interpolationConfig?: InterpolationConfig): ASTWithSource | null;
    parseInterpolationExpression(expression: string, location: string, absoluteOffset: number): ASTWithSource;
    private createInterpolationAst;
    splitInterpolation(input: string, location: string, interpolatedTokens: InterpolatedAttributeToken[] | InterpolatedTextToken[] | null, interpolationConfig?: InterpolationConfig): SplitInterpolation;
    wrapLiteralPrimitive(input: string | null, location: string, absoluteOffset: number): ASTWithSource;
    private _stripComments;
    private _commentStart;
    private _checkNoInterpolation;
    private _getInterpolationEndIndex;
    private _forEachUnquotedChar;
}
export declare class _ParseAST {
    input: string;
    location: string;
    absoluteOffset: number;
    tokens: Token[];
    parseFlags: ParseFlags;
    private errors;
    private offset;
    private rparensExpected;
    private rbracketsExpected;
    private rbracesExpected;
    private context;
    private sourceSpanCache;
    index: number;
    constructor(input: string, location: string, absoluteOffset: number, tokens: Token[], parseFlags: ParseFlags, errors: ParserError[], offset: number);
    peek(offset: number): Token;
    get next(): Token;
    get atEOF(): boolean;
    get inputIndex(): number;
    get currentEndIndex(): number;
    get currentAbsoluteOffset(): number;
    span(start: number, artificialEndIndex?: number): ParseSpan;
    sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan;
    advance(): void;
    private withContext;
    consumeOptionalCharacter(code: number): boolean;
    peekKeywordLet(): boolean;
    peekKeywordAs(): boolean;
    expectCharacter(code: number): void;
    consumeOptionalOperator(op: string): boolean;
    expectOperator(operator: string): void;
    prettyPrintToken(tok: Token): string;
    expectIdentifierOrKeyword(): string | null;
    expectIdentifierOrKeywordOrString(): string;
    parseChain(): AST;
    parsePipe(): AST;
    parseExpression(): AST;
    parseConditional(): AST;
    parseLogicalOr(): AST;
    parseLogicalAnd(): AST;
    parseNullishCoalescing(): AST;
    parseEquality(): AST;
    parseRelational(): AST;
    parseAdditive(): AST;
    parseMultiplicative(): AST;
    parsePrefix(): AST;
    parseCallChain(): AST;
    parsePrimary(): AST;
    parseExpressionList(terminator: number): AST[];
    parseLiteralMap(): LiteralMap;
    parseAccessMember(readReceiver: AST, start: number, isSafe: boolean): AST;
    parseCall(receiver: AST, start: number, isSafe: boolean): AST;
    private consumeOptionalAssignment;
    parseCallArguments(): BindingPipe[];
    expectTemplateBindingKey(): TemplateBindingIdentifier;
    parseTemplateBindings(templateKey: TemplateBindingIdentifier): TemplateBindingParseResult;
    parseKeyedReadOrWrite(receiver: AST, start: number, isSafe: boolean): AST;
    private parseDirectiveKeywordBindings;
    private getDirectiveBoundTarget;
    private parseAsBinding;
    private parseLetBinding;
    private consumeStatementTerminator;
    error(message: string, index?: number | null): void;
    private locationText;
    private _reportErrorForPrivateIdentifier;
    private skip;
}
//# sourceMappingURL=parser.d.ts.map