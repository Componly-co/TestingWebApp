var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { createElement as _createElement } from "react";
import { ActionIcon, createStyles, Flex, Group, MultiSelect as MantineMultiSelect, Stack, Text } from "@mantine/core";
import { useFocusWithin } from "@mantine/hooks";
import { ChevronDown, HelpCircle, Check } from "lucide-react";
import { useRef } from "react";
import { Variants } from "../Badge";
import { Colors, FontSizes, Layout } from "../../design-tokens";
import { Tags, TagsSize } from "../Tags";
import { Tooltip } from "../Tooltip";
// Ref: https://mantine.dev/core/multi-select/#custom-label-component
var ValueComponent = function (_a) {
    var onRemove = _a.onRemove, className = _a.className, // Applies spacing stylings
    label = _a.label, error = _a.error, focused = _a.focused, rest = __rest(_a, ["onRemove", "className", "label", "error", "focused"]);
    var variant = Variants.Neutral;
    if (typeof error === "string") {
        variant = Variants.Error;
    }
    else if (focused === true) {
        variant = Variants.Accent;
    }
    return (_jsx("div", __assign({ className: className }, { children: _createElement(Tags, __assign({}, rest, { label: label, key: label, onClose: onRemove, size: TagsSize.Normal, variant: variant })) })));
};
function useSearchProps(_a) {
    var searchable = _a.searchable, data = _a.data;
    var values = useRef(data);
    if (!searchable)
        return {};
    return {
        creatable: true,
        data: values.current,
        getCreateLabel: function (query) { return "+ Create ".concat(query); },
        onCreate: function (query) {
            var item = { value: query, label: query };
            values.current = __spreadArray(__spreadArray([], values.current, true), [item], false);
            return item;
        },
    };
}
export function MultiSelect(_a) {
    var label = _a.label, optionalText = _a.optionalText, onHelpIconClick = _a.onHelpIconClick, error = _a.error, helperText = _a.helperText, data = _a.data, placeholder = _a.placeholder, disabled = _a.disabled, sx = _a.sx, onChange = _a.onChange, _b = _a.showHelpIcon, showHelpIcon = _b === void 0 ? true : _b, _c = _a.searchable, searchable = _c === void 0 ? false : _c, _d = _a.helpTooltipProps, helpTooltipProps = _d === void 0 ? {
        children: null,
        label: null,
        position: "top",
        title: "Header",
        description: "In publishing and graphic design, Lorem ipsum is a placeholder text commonly used to demonstrate the visual form of a document or a typeface without relying on meaningful content.",
    } : _d, selector = _a.selector, rest = __rest(_a, ["label", "optionalText", "onHelpIconClick", "error", "helperText", "data", "placeholder", "disabled", "sx", "onChange", "showHelpIcon", "searchable", "helpTooltipProps", "selector"]);
    var _e = useFocusWithin(), ref = _e.ref, focused = _e.focused; // 'useFocusWithin' hook detects if any element within has focus, it works the same way as ':focus-within' CSS selector
    var searchableProps = useSearchProps({ searchable: searchable, data: data });
    return (_jsxs(Stack, __assign({ spacing: Layout.sm, sx: sx }, { children: [_jsxs(Flex, __assign({ direction: "row", align: "center", justify: "space-between" }, { children: [_jsxs(Group, __assign({ spacing: Layout.xs, align: "center" }, { children: [_jsx(Text, __assign({ sx: __assign({}, FontSizes.Subtitle2) }, { children: label })), showHelpIcon && (_jsx(Tooltip, __assign({}, helpTooltipProps, { children: _jsx(ActionIcon, __assign({ size: Layout.TBR, variant: "subtle", onClick: onHelpIconClick, color: "gray", radius: "xl" }, { children: _jsx(HelpCircle, { size: "19px", style: {
                                            fill: Colors.Neutral[500],
                                            stroke: "white"
                                        } }) })) })))] })), typeof optionalText === "string" ? (_jsx(Text, __assign({ color: Colors.DarkGrey[600], sx: __assign({}, FontSizes.Helper) }, { children: optionalText }))) : undefined] })), _jsx(MantineMultiSelect, __assign({ ref: ref, error: error, disabled: disabled, data: data.map(function (ele) { return (__assign(__assign({}, ele), { error: error, focused: focused })); }), placeholder: placeholder, onChange: onChange, styles: {
                    label: __assign({}, FontSizes.Subtitle2),
                    error: __assign(__assign({}, FontSizes.Helper), { color: Colors.Badge.error.Label }),
                    /**
                     * To apply styling as per focused state used 'focused' state accquired from 'useFocusWithin' hook
                     * since 'focus' event of 'input' is not working due to transfer of focus
                     * from 'input' to 'dropdown' once 'input' is clicked.
                     */
                    input: __assign(__assign({}, FontSizes.Body2), { "&[aria-invalid='false']": {
                            border: focused === true ? "1.5px solid ".concat(Colors.Default.Background) : undefined,
                        }, "&[aria-invalid='true']": {
                            border: focused === true
                                ? "1.5px solid ".concat(Colors.Button.destructive.Hover.Text)
                                : undefined,
                        } }),
                    item: __assign(__assign({}, FontSizes.Body2), { borderRadius: "30px" }),
                    dropdown: {
                        borderRadius: "30px",
                    },
                    /**
                     * Will make right section icon to not be a target of any pointer events,
                     * thus whole 'MultiSelect' will get precedance over 'pointer' events.
                     * Ref: https://mantine.dev/core/multi-select/#right-section
                     */
                    rightSection: { pointerEvents: "none" },
                }, radius: "lg", rightSection: _jsx(ChevronDown, {}), valueComponent: ValueComponent, searchable: searchable }, selector, searchableProps, rest)), typeof error !== "string" ? (_jsx(Text, __assign({ color: Colors.DarkGrey[600], sx: __assign({}, FontSizes.Helper) }, { children: helperText }))) : undefined] })));
}
var useStyles = createStyles(function () { return ({
    dropdownItem: {
        position: 'relative',
        fontSize: 14,
        lineHeight: '24px',
        color: "#000000",
        margin: '0 10px 2px',
        padding: '8px 8px',
        borderRadius: 30,
        '&:hover': {
            background: "#F5F6F8"
        }
    },
    dropdownItemTitle: {
        margin: 0,
    },
    check: {
        color: '#007BFF',
        position: 'absolute',
        right: 10
    }
}); });
export var SelectedItem = function (_a) {
    var label = _a.label, onMouseDown = _a.onMouseDown, selected = _a.selected, ref = _a.ref, truncate = _a.truncate;
    var classes = useStyles().classes;
    var slice = selected ? 14 : 17;
    return (_jsxs(Group, __assign({ noWrap: true, ref: ref, onClick: onMouseDown, className: classes.dropdownItem }, { children: [_jsxs(Text, __assign({ truncate: true, className: classes.dropdownItemTitle }, { children: [truncate ? label.slice(0, slice) : label, label.length > slice && truncate ? '...' : ''] })), selected && _jsx(Check, { size: 20, className: classes.check })] })));
};
