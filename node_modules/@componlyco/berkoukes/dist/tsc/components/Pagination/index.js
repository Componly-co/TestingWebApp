var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx } from "react/jsx-runtime";
import { Pagination as MantinePagination } from "@mantine/core";
import { ArrowLeft, ArrowRight } from "lucide-react";
import { Colors, FontSizes, Layout } from "../../design-tokens";
export function Pagination(_a) {
    var total = _a.total, selector = _a.selector, props = __rest(_a, ["total", "selector"]);
    return (_jsx(MantinePagination, __assign({ total: total < 1 ? 1 : total, size: "md", radius: "xl", previousIcon: ArrowLeft, nextIcon: ArrowRight, styles: {
            control: __assign(__assign({ color: Colors.Neutral[700], borderWidth: "0px" }, FontSizes.Subtitle3), { '&:first-of-type, &:last-of-type': {
                    color: Colors.DarkGrey.black,
                    border: "1px solid ".concat(Colors.Border.filled),
                    boxShadow: '0px 1px 2px -1px rgba(10, 9, 11, 0.04), 0px 2px 14px -1px rgba(10, 9, 11, 0.09)',
                }, "&[data-active]": {
                    background: "transparent",
                    color: Colors.Default.Background,
                    borderColor: Colors.Default.Background,
                    borderWidth: "2px",
                    "&:not([data-disabled]):hover": {
                        background: Colors.Disabled.Background,
                    },
                }, "&:not([data-disabled]):hover": {
                    background: Colors.Disabled.Background,
                    cursor: 'image-set',
                }, "&[disabled]": {
                    background: Colors.Disabled.Background,
                    cursor: 'image-set',
                    pointerEvents: 'auto'
                } }),
            dots: {
                borderRadius: "50%",
                color: Colors.Disabled.Text,
                background: Colors.Disabled.Background,
            },
        }, sx: {
            gap: Layout.md
        } }, selector, props)));
}
